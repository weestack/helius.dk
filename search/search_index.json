{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>What we know is but a drop in a vast ocean</p>"},{"location":"#heliusdk","title":"Helius.dk","text":"<p>Welcome to my blog, and I hope it finds you well. This blog is dedicated to my hobby projects, where I decided to share my journey this year and make everything open source. I'm curious and have plenty of ideas, so I already know all the topics I'll be exploring in 2025. </p> <ul> <li>Solana sniper   Building a blazing fast Solana sniper in Rust</li> <li>Solana Copy trading   Expected to start Q2 2025</li> <li>Rust Limit order book   Expected to start Q3 2025</li> <li>On-chain Rust trader   Expected to start Q4 2025</li> </ul>"},{"location":"donations/","title":"hello world","text":""},{"location":"about/","title":"About me","text":"<p>Hello, and thank you for the interest in me!</p> <p>I\u2019m Alexander H\u00f8gh, a Senior DevOps Engineer.</p>"},{"location":"about/#who-am-i","title":"Who Am I","text":"<p>I\u2019m a Senior DevOps Engineer with a passion for Rust, Blockchain, and all things tech. Back in 2024, crypto caught my attention, and I began exploring algorithmic trading and technical analysis. Over a few months, I managed to create several Python algorithms for Freqtrade, implementing: - RSI (Relative Strength Index) - Harmonic Patterns: Shark, Crab, Butterfly, AB=CD, and AB=0 - Sporadic price channels that follow market trends with support and resistance levels - Numerous other algorithms</p> <p>Then... well, you know how hobbies can be\u2014they tend to spiral out of control! I went down the rabbit hole, diving into Web3, Blockchains, Smartcontracts, DApps, and even creating a few memecoin snipers.</p> <p>Recently, I completed a Solana sniper project, where I set up an RPC node on a Latitude.sh server with Shredstream, Yellowstone gRPC, and Prometheus.</p> <p>Now, I\u2019m eager to contribute more. If you\u2019ve scrolled through my GitHub contributions, you might be disappointed\u2014most of my work has been closed-source for clients. I aim to change that in 2025 and make meaningful contributions to Open Source.</p> <ul> <li>An Open Source Solana Sniper in Rust</li> <li>All of my algorithmic trading code</li> <li>A Limit Order Book smart contract for Solana</li> <li>A functional Rust trader for on-chain use</li> </ul> <p>I\u2019ve already started with the Solana Sniper and will release everything in chunks, ensuring the code is clean, user-friendly, and well-documented with blog posts explaining every step.</p>"},{"location":"about/#devops","title":"DevOps","text":"<p>My Linux journey began at 15, and it\u2019s been a cornerstone of my career ever since. Over the years, I\u2019ve built expertise in:</p> <ul> <li>Docker and Docker Compose, Kubernetes</li> <li>AWS, GCP, and DigitalOcean</li> <li>System hardening, monitoring, and cluster setups</li> <li>Provisioning, backups, and security</li> </ul> <p>Today, as a Senior DevOps Engineer, my responsibilities include:</p> <ul> <li>Managing 100+ dedicated servers and numerous cloud instances</li> <li>Provisioning, monitoring, backups, and security</li> <li>Acting as tech lead for a multi-million-dollar eCommerce project</li> <li>Mentoring two mentees</li> <li>Sparring with seven development teams</li> </ul>"},{"location":"about/#ecommerce","title":"Ecommerce","text":"<p>I\u2019ve been a developer in the eCommerce business for almost 10 years, starting with smaller brands and now working with multi-million-dollar brands.</p> <p>One of my recent projects involved modernizing a completely non-digitalized industry. This client relied on products from over 50 suppliers, each providing non-standardized Excel sheets with no fixed reference points, no product number, different product names. Together, we tackled the challenge by: - Matching Excel data with existing products l\u00e6everaging Elasticsearch\u2019s fuzzy finder and n-grams - Creating product variants - Implementing dropshipping logic - Adding a touch of magic :rabbit:</p>"},{"location":"about/#background","title":"Background","text":"<p>I spun up my first Linux server at 15 and quickly became a \"script kiddie,\" making mods for games like Modern Warfare 2. Those zombie mods were fun... until Steam VAC banned me across all my Valve games :smirk:.</p> <p>In 2014, I got serious about development. I created a time check-in system for my employer, who had ~120 employees. Each month, his wife received non-standardized Excel sheets of working hours. I taught myself PHP and MySQL, developing a system that standardized the data in just two months\u2014all while working 55 hours a week in a different role. That project confirmed my passion for development, problem-solving, and daily challenges.</p> <p>Since then, I\u2019ve freelanced for over 30 regular clients across Denmark, Norway, and the USA.</p>"},{"location":"blog/","title":"Posts","text":""},{"location":"blog/2026/01/28/hot-reloading/","title":"Hot reloading","text":"","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#hot-reloading","title":"Hot reloading","text":"<p>Hot reloading is an effective way to keep development iterations fast. Furthermore, it could\u2014and probably already does\u2014help solve some production issues. Here, we will take a naive and simplified look at how it could be used for a live trader to reload a critical component without restarting the entire suite, but instead only a specific component.    </p> <p>The layout of our small example will be simple. We will have a main CLI binary and a shared dynamic library that we hot reload. More specifically, we create a CLI that prints the price of an asset on Binance every five seconds. We can then utilize the hot-reload functionality to introduce an order book for the spread or a second API interface at runtime, provided we keep our logic tight.</p> <p>While our example is simple, imagine having a live trader with a preflight time of one minute or more. It might need to download a number of candles to initialize indicators, or even more data to normalize values for machine learning. It could also be used for high-frequency trading, where even a minute of downtime is critical for current positions and, even worse, costs money.</p>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#limitations","title":"Limitations","text":"<p>We have a few limitations or at least obstacles that we need to address to achieve hot reloadability successfully.</p> <ul> <li>Rust has no stable ABI</li> <li>We have to introduce a stable ABI</li> <li>Components need to be decoupled from the start by this design</li> </ul>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#abi","title":"ABI","text":"<p>Rust does not have a stable Application Binary Interface (ABI). This is a design choice in rustc to allow optimization of memory layout along with other performance improvements. However, this represents a significant challenge. If we were to rely on Rust\u2019s unstable ABI, which makes no guarantees about types such as String or Vec, even the slightest change could cause a crash.</p> <p>Because of this, we need to bridge into something that does have a stable ABI. This is where the Foreign Function Interface (FFI) comes into play. FFI is simply the ability to call a procedure or routine from a different language. In this example, we will use the stable ABI provided by C.</p>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#price-printer","title":"Price printer","text":"<p><pre><code>[package]\nname = \"price_printer\"\nauthors.workspace = true\nedition.workspace = true\n\n[dependencies]\nreqwest = { version = \"0.13.1\", features = [\"json\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nserde = { version = \"1\", features = [\"derive\"] }\n\n[lib]\ncrate-type = [\"rlib\", \"dylib\"]\n</code></pre> Pay attention to dylib, this will create dynamic shared library that other languages can connect to with abi, we are going to be using this in our main loop to load the dynamic library directly into the other part of our program as a hot pluggable component. </p> <p><pre><code>use std::time::Duration;\nuse serde::Deserialize;\nuse reqwest::Error;\nuse tokio::time::sleep;\n\n#[derive(Deserialize, Debug, Clone)]\npub struct TickerPrice {\n    pub symbol: String,\n    pub price: String,\n}\n\n#[unsafe(no_mangle)]\npub extern \"C\" fn price_printer(keep_running: *const std::sync::atomic::AtomicBool) {\n    let rt = tokio::runtime::Builder::new_current_thread()\n        .enable_all()\n        .build()\n        .unwrap();\n\n    let symbol = \"SOLUSDC\";\n    let url = format!(\"https://api.binance.com/api/v3/ticker/price?symbol={}\", symbol);\n    let client = reqwest::Client::new();\n\n    rt.block_on(async {\n        loop {\n            if unsafe { (*keep_running).load(std::sync::atomic::Ordering::Relaxed) } {\n                break;\n            }\n\n            sleep(Duration::from_secs(1)).await;\n            let response = client.get(&amp;url).send().await.unwrap();\n            let price: TickerPrice = response.json().await.unwrap();\n            print!(\"{}: {}\\r\\n\", price.symbol, price.price);\n        }\n    });\n}\n\npub async fn fetch_price(client: &amp;reqwest::Client, url: &amp;str) -&gt; Result&lt;TickerPrice, Error&gt; {\n    let response = client.get(url).send().await?;\n    let ticker: TickerPrice = response.json().await?;\n    Ok(ticker)\n}\n</code></pre> Notice that we do not define the price_printer as async, by default using async with FFI is a different ballgame as the std to my knowlede has no safe implementation of async FFI, so the example got the easy route.  </p>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#main-loop","title":"Main loop","text":"<pre><code>[package]\nname = \"main\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\ncrossterm = \"0.29.0\"\nlibloading = \"0.9.0\"\nanyhow = \"1.0.100\"\n</code></pre> <pre><code>use crossterm::{\n    event::{self, Event, KeyCode, KeyEvent, KeyModifiers},\n    terminal,\n};\nuse std::io;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse libloading::Library;\n\ntype PriceYielder = unsafe extern \"C\" fn(*const AtomicBool);\n\nasync fn trader() -&gt; anyhow::Result&lt;()&gt; {\n    let lib_path = format!(\"target/debug/libprice_printer.dylib\");\n\n    loop {\n        let lib = unsafe { Library::new(&amp;lib_path)? };\n        let price_yielder: libloading::Symbol&lt;PriceYielder&gt; = unsafe { lib.get(b\"price_yielder\")? };\n\n        let stop_signal = Arc::new(AtomicBool::new(false));\n        let stop_signal_clone = Arc::clone(&amp;stop_signal);\n        let func: PriceYielder = *price_yielder;\n        let spawn = tokio::task::spawn_blocking(move || {\n            let ptr = Arc::as_ptr(&amp;stop_signal_clone);\n            unsafe {\n                func(ptr);\n            }\n        });\n\n        let input = wait_for_input()?;\n        stop_signal.store(true, Ordering::Relaxed);\n        spawn.await?;\n\n        if input {\n            continue\n        } else {\n            break;\n        }\n\n    }\n    Ok(())\n}\n\n\n#[tokio::main]\nasync fn main() {\n    trader().await.unwrap();\n}\n\nfn wait_for_input() -&gt; io::Result&lt;bool&gt; {\n    terminal::enable_raw_mode()?;\n\n    loop {\n        if let Event::Key(KeyEvent { code, modifiers, .. }) = event::read()? {\n            if code == KeyCode::Char('r') &amp;&amp; modifiers.contains(KeyModifiers::CONTROL) {\n                terminal::disable_raw_mode()?;\n                return Ok(true);\n            }\n\n            if code == KeyCode::Char('c') &amp;&amp; modifiers.contains(KeyModifiers::CONTROL)  {\n                terminal::disable_raw_mode()?;\n                return Ok(false);\n            }\n        }\n    }\n}\n</code></pre>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#demonstration","title":"Demonstration","text":"<p>For the demononstration, I simply started the program, went back and changed the price printer to print BTCUSDC instead of SOLUSDC, did a cargo build followed by ctrl + r in the terminal.  </p> <p></p> <p>Hot reload from SOLUSDC to BTCUSDC</p>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2026/01/28/hot-reloading/#conclusion","title":"Conclusion","text":"<p>While this was a soft and simple introduction, the application and usecases for hot reloading is numerous, we barely touched the subject here, inter communication is also possible with say a C struct, that could help preserve states between hot reloads.</p>","tags":["Rust","External C","FFI","Unsafe rust"]},{"location":"blog/2025/02/17/making-a-stable-coin-on-solana/","title":"Making a stable coin on Solana","text":"<p>Recently, I spoke with someone about creating a stablecoin. I had given it some thought myself and asked him:</p> <p>So how do you stabilize it on the curve?</p> <p>By this, I meant how to keep it steady at $1 or \u20ac1 because whenever you mint a coin using the token program and start swapping in and out, the price fluctuates. He responded:</p> <p>You need to make triggers to keep the peg in place</p> <p>He also mentioned collateralization and other concepts, but that\u2019s not particularly relevant to this article. Being me, I kept thinking about it, and these are my (probably naive) solutions to creating a stablecoin:  </p>","tags":["Solana"]},{"location":"blog/2025/02/17/making-a-stable-coin-on-solana/#idea-one-constant-product","title":"Idea one Constant product","text":"<p>Swap distribution on a stable coin</p>","tags":["Solana"]},{"location":"blog/2025/02/17/making-a-stable-coin-on-solana/#the-math","title":"The math","text":"<p>When a token is created on Solana using the token program, its value is determined by the Constant product. Below is a simplified version of the necessary calculation: Minted token supply / Solana supply 5000 / 5000 = 1 sol</p> <p>If we wanted to create a token that always remains worth 1 SOL, we could develop a smart contract that mints on buys and burns on sells to maintain equilibrium.</p> <p>However, a stablecoin should probably track something more stable\u2014like the Euro. For that, we need an oracle.</p> <p>An oracle in smart contracts is a service to fetch off-chain data, such as the euro price.</p> <p>Now, the math effectively becomes: minted_supply / (solana supply / euro price) 5000 / (5000 / 7.5) = 5000 / 666.6667 = 7.5  </p> <p>The status quo can still be maintained by minting and burning with corresponding buys and sells directly within the smart contract. With the help of the oracle, it can automatically adjust itself whenever the Euro fluctuates.</p> <p>That concludes Idea One, which already seems to exist in the form of this stable swap program.</p>","tags":["Solana"]},{"location":"blog/2025/02/17/making-a-stable-coin-on-solana/#idea-two-liquidity-providing","title":"Idea two, liquidity providing","text":"<p>Idea two builds upon the first but introduces a slight... let\u2019s say profit incentive (Disclaimer: This is just an idea\u2014there may be regulatory concerns).  </p> <p>Let\u2019s say you create a \u20ac100M stablecoin, meaning you swap \u20ac100M for the equivalent amount of SOL. At today\u2019s exchange rate (\u20ac169.49 per SOL), that would equal 590,005.31 SOL. To maintain its value at \u20ac1, we apply the formula from Idea One and isolate the unknown.  </p> <p>The real difference in this idea is using event listeners on Solana for our mint and taking the following actions:  </p> <ul> <li>If the value drops below \u20ac1, we swap in SOL to push it back up.  </li> <li>If the value rises above \u20ac1, we swap out SOL to bring it back down.  </li> </ul> <p>This is liquidity providing in its purest/simplest form. However, there are several challenges to consider, such as sandwich attacks, arbitrage bots, and so on.</p> <p>This being liquidity providing also means you need to account for price fluctuations while also ensuring the ability to stake the invested supply.</p> <ul> <li>Sandwich attacks can be mitigated by using Jito to wrap swaps.</li> <li>Arbitrage bots are harder to counter and require technical finesse\u2014primarily by being faster.</li> </ul>","tags":["Solana"]},{"location":"blog/2025/02/17/making-a-stable-coin-on-solana/#wrap-up","title":"Wrap up","text":"<p>That\u2019s it for my thoughts on stablecoins. They are by no means a new concept and operate in a heavily regulated field. This article may not have provided the exact insights you were hoping for, but at the very least, it should give you a few ideas to explore on this topic. </p>","tags":["Solana"]},{"location":"blog/2025/02/17/making-a-stable-coin-on-solana/#disclaimer","title":"Disclaimer:","text":"<p>The information provided in this blog is for educational and informational purposes only. It does not constitute financial, legal, or investment advice. Always check the regulations in effect in your jurisdiction before considering any concepts discussed here. I take no responsibility for any actions taken based on this content.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/","title":"Writing a Raydium sniper in Rust part 2","text":"","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#writing-a-solana-raydium-sniper-in-rust-part-2","title":"Writing a Solana Raydium sniper in Rust part 2","text":"<p>This is part two of this series, where we are creating a Solana sniper bot for Raydium from scratch in Rust. See the first post here which includes an introduction about why we use a compiled language instead of JavaScript, as well as a brief introduction about me. You can find the latest GitHub source here, which will be updated with each new post.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#setting-up-a-logger","title":"Setting up a logger","text":"<p>Using logging in any software is essential, as it helps with debugging. Standard log levels include trace, debug, info, warn, and error.</p> <p>For logging, we will use <code>env_logger</code> to configure the standard logger, and <code>log</code> to write logs at different levels.</p> <p><code>Cargo.toml</code></p> <pre><code># add under workspace.dependencies in root Cargo.toml\nenv_logger = \"0.11.6\"\nlog = \"0.4.22\"\n# add under dependencies in utils/Cargo.tml\nenv_logger = { workspace = true }\nlog = { workspace = true }\n# add under dependencies in sniper/Cargo.tml\nlog = { workspace = true }\n</code></pre> <p>We use <code>env_logger</code> to modify Rust's standard log format so that all logs include timestamps formatted to milliseconds. This helps with orientation later by also displaying the file we are logging from, as shown in the image below.</p> <p></p> <p>Terminal output of a started websocket in our rust program</p> <p>Inside <code>utils/src/env/env.rs</code>, update the rest of the code with the following:</p> <pre><code>use std::{env, fmt, fs, io};\nuse std::path::Path;\nuse std::sync::Arc;\nuse solana_program::native_token::lamports_to_sol;\nuse crate::env::errors::EnvErrors;\nuse env_logger::{Builder, Env as EnvBuilder}; //alias so we don't clash with our own Env struct ;\nuse log::{LevelFilter};\n\npub struct Env {\n    pub loglevel: Arc&lt;LevelFilter&gt;, // add LevelFilter eg enum warn, info, debug etc\n    pub websocket_endpoint: Arc&lt;String&gt;,\n    pub rpc_endpoint: Arc&lt;String&gt;,\n    pub private_key: Arc&lt;String&gt;,\n    pub swap_amount: Arc&lt;u64&gt;,\n    pub swap_priority_fee: Arc&lt;u64&gt;,\n}\n\nimpl Env {\n    pub fn new() -&gt; Result&lt;Self, EnvErrors&gt; {\n        // Test if .env exists or give the option to create one from .env.dist\n        let path = Path::new(\".env\");\n        if ! path.exists() {\n            println!(\"Could not find .env, would you like to use .env.dist as a template instead? (y/n)\");\n            create_env().expect(\"Failed creating .env file\");\n        }\n        dotenv::from_path(\".env\").ok();\n\n        /* Read LOG_LEVEL from .env */\n        let loglevel = Arc::new(parse_log_level(env::var(\"LOG_LEVEL\")?));\n\n        let websocket_endpoint = Arc::new(env::var(\"WEBSOCKET_ENDPOINT\")?);\n        let rpc_endpoint = Arc::new(env::var(\"RPC_ENDPOINT\")?);\n\n        let private_key = Arc::new(env::var(\"PRIVATE_KEYPAIR\")?);\n        let swap_amount = Arc::new(env::var(\"SWAP_AMOUNT\")?.parse::&lt;u64&gt;().unwrap());\n        let swap_priority_fee = Arc::new(env::var(\"SWAP_PRIORITY_FEE\")?.parse::&lt;u64&gt;().unwrap());\n\n        Ok(\n            Self {\n                loglevel, // add loglevel to initialization of our struct\n                websocket_endpoint,\n                rpc_endpoint,\n                private_key,\n                swap_amount,\n                swap_priority_fee,\n            }\n        )\n    }\n\n    pub fn setup_logger(&amp;self) {\n        // setup our custom logging format\n        let env = EnvBuilder::default();\n\n        Builder::from_env(env)\n            .filter_level(*self.loglevel) // level from .env\n            .format_level(false)\n            .format_timestamp_millis() // display timestamp in milliseconds\n            .init();\n    }\n}\n\nimpl fmt::Display for Env {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        writeln!(f, \"===================== ENVS Loaded =====================\\r\\n\\\n        websocket_endpoint: {:?}\\r\\n\\\n        rpc endpoint:       {:?}\\r\\n\\\n        private wallet:     {:?}\\r\\n\\\n        swap amount:        {:?} sol\\r\\n\\\n        swap_priority_fee:  {:?} sol\\r\\n\\\n        total per trade:    {:?} sol\\r\\n\\\n        =====================================================\",\n                 self.websocket_endpoint,\n                 self.rpc_endpoint,\n                 self.private_key,\n                 lamports_to_sol(*self.swap_amount),\n                 lamports_to_sol(*self.swap_priority_fee),\n                 lamports_to_sol(*self.swap_amount.clone() + *self.swap_priority_fee.clone())\n        )\n    }\n}\n\nfn create_env() -&gt; std::io::Result&lt;()&gt; {\n    let source = \".env.dist\";\n    let destination = \".env\";\n\n    println!(\"Do you want to copy '{}' to '{}' (y/n)?\", source, destination);\n\n    let mut input = String::new();\n    io::stdin().read_line(&amp;mut input)?;\n\n    // Trim input and check the response\n    if input.trim().eq_ignore_ascii_case(\"y\") {\n        // Perform the copy\n        fs::copy(source, destination)?;\n        println!(\"File successfully copied to '{}'.\", destination);\n    } else {\n        println!(\"Operation canceled.\");\n    }\n\n    Ok(())\n}\n\n\n// Parse LOG_LEVEL from .env to LevelFilter or default to INFO\nfn parse_log_level(log_level: String) -&gt; LevelFilter {\n    match log_level.to_lowercase().as_str() {\n        \"off\" =&gt; LevelFilter::Off,\n        \"error\" =&gt; LevelFilter::Error,\n        \"warn\" =&gt; LevelFilter::Warn,\n        \"info\" =&gt; LevelFilter::Info,\n        \"debug\" =&gt; LevelFilter::Debug,\n        \"trace\" =&gt; LevelFilter::Trace,\n        _ =&gt; LevelFilter::Info // defaults to info, if wrong loglevel given\n    }\n}\n</code></pre> <p>Inside Utils/src/env/env.rs we added this new method inside impl:</p> <p><pre><code>pub fn setup_logger(&amp;self) {\n        let env = EnvBuilder::default();\n         Builder::from_env(env)\n            .filter_level(*self.loglevel)\n            .format_level(false)\n            .format_timestamp_millis()\n            .init();\n}\n</code></pre> Here, we simply initialize the <code>env_logger</code>, set the log level from our <code>.env</code> file, and configure it to display timestamps in milliseconds. For other ways to customize the standard logging format, refer to the `env_logger documentation here.</p> <p>The <code>&amp;self</code> keyword indicates that this is now a callable method within our <code>env</code> struct.</p> <p>Finally update main.rs in sniper/srv/mains.rs to:</p> <pre><code>use utils::env::env::Env;\n\n#[tokio::main]\nasync fn main() {\n    /* Load in ENV from .env, or suggest creating from .env.dist */\n    let env = Env::new().unwrap();\n    env.setup_logger();\n}\n</code></pre> <p>With that in place, we call <code>setup_logger</code> to change the standard logging format, and we will now see logs with millisecond precision. We can use the <code>debug!</code>, <code>info!</code>, <code>warn!</code>, and <code>error!</code> macros to specify log levels when logging events or the state of parts of our program.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#subscribing-to-raydium-events","title":"Subscribing to Raydium events","text":"<p>To listen for all new tokens created on Raydium, we first need to understand a few concepts.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#amm","title":"AMM","text":"<p>When we refer to a new token on Raydium, we are actually talking about a new liquidity AMM (Automated Market Maker) pool. For regular token swapping on Raydium, it is common practice to use their comprehensive main JSON file, which contains account addresses for all tokens. This file is updated several times a day and exceeds 500 MB in size. However, for sniping, this approach is not viable due to its size and update frequency. Instead, we need to find an alternative way to collect token addresses within the first few ms after a new token is released.</p> <p>An AMM pool is paired with either SOL or USDC for trading. This is why new tokens often appear as <code>&lt;token&gt;/WSOL</code> or <code>&lt;token&gt;/USDC</code> on platforms like Dexscreener. `WSOL refers to wrapped SOL, which is necessary for using SOL in swaps. This wrapping process allows SOL to be compatible with the SPL token standard used by Solana. However, this logic is often abstracted away, so users may not need to handle wrapping directly.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#transactions","title":"Transactions","text":"<p>In Solana, transactions are the process of transferring tokens or interacting with smart contracts on the blockchain. Each transaction consists of one or more instructions that are executed on the network. Solana\u2019s high throughput is achieved through its Proof of History (PoH) consensus mechanism, which timestamps and orders transactions. Transactions are processed in parallel, allowing for faster confirmation times. A typical transaction includes a fee paid to validators, a signature from the sender, and updates to accounts or smart contracts. Solana\u2019s scalability ensures transactions are processed quickly and efficiently.</p> <p>For our sniper, this is essential knowlede as we listen for interactions with Raydium\u2019s smart contract, specifically the <code>initialize2</code> event, which is triggered when a new liquidity pool is created.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#commitment-levels","title":"Commitment Levels","text":"<p>In Solana, commitment levels represent different stages in the transaction lifecycle. At the \u2018processed\u2019 level, a transaction is received by the network and the leader is proposing that given transaction along with others in a block, which typically takes from 10 ms to 3 seconds, depending on network congestion. Then, if the transaction matches the smart contract(s) it\u2019s interacting with and has the required funds for its actions, it will be confirmed. Finally, the transaction reaches the \u2018finalized\u2019 stage once the leader and corresponding voters have processed the block containing the transaction.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#websocket-subscriber","title":"Websocket subscriber","text":"<p>Now with a few basics under our belt, lets go ahead and create our websocket subscriber.</p> <p>Create the file sniper/src/oracle/websocket.rs</p> <pre><code>use std::sync::Arc;\nuse solana_client::{\n    nonblocking::pubsub_client::PubsubClient,\n    rpc_config::{RpcTransactionLogsConfig, RpcTransactionLogsFilter},\n};\nuse solana_sdk::commitment_config::{CommitmentConfig, CommitmentLevel};\nuse futures::StreamExt;\nuse log::info;\n\npub struct SolanaSubscriber {\n    client: PubsubClient,\n    config_level: CommitmentConfig,\n    subscribe_to: Vec&lt;String&gt;\n}\n\n\nimpl SolanaSubscriber {\n    pub async fn new(ws_url: Arc&lt;String&gt;, config_level: CommitmentConfig, subscribe_to: Vec&lt;String&gt;) -&gt; Self {\n        let client = PubsubClient::new(ws_url.clone().as_str())\n            .await\n            .expect(format!(\"Failed to connect to {}\", ws_url).as_str());\n\n        SolanaSubscriber {\n            client,\n            config_level,\n            subscribe_to\n        }\n    }\n\n    pub async fn start_thread(&amp;self) {\n        info!(\"Starting Solana websocket subscriber\");\n        let subscribe_to = self.subscribe_to.clone();\n        let config_level = self.config_level.clone();\n        let (mut stream, _) = self.client.logs_subscribe(\n            RpcTransactionLogsFilter::Mentions(\n                subscribe_to\n            ),\n            RpcTransactionLogsConfig {\n                commitment: Some(config_level),\n            }\n        ).await.expect(\"Failed to subscribe to Logs!\");\n\n        loop {\n            while let Some(response) = stream.next().await {\n\n                for log in &amp;response.value.logs {\n                    /* skip all events that does not contain initialize2 eg token create */\n                    if !log.contains(\"initialize2\") {\n                        continue\n                    }\n                    info!(\"Received tx https://solscan.io/tx/{}\", response.value.signature);\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Update sniper/src/main.rs</p> <pre><code>mod oracle;\nuse solana_sdk::commitment_config::CommitmentConfig;\nuse utils::env::env::Env;\n\n#[tokio::main]\nasync fn main() {\n    /* Load in ENV from .env, or suggest creating from .env.dist */\n    let env = Env::new().unwrap();\n    env.setup_logger();\n\n    let subscribe_to_raydium = vec![\n        \"675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8\".to_string()\n    ];\n\n    /* Listen for all events regarding Raydium */\n    let subscriber = oracle::websocket::SolanaSubscriber::new(\n        env.websocket_endpoint.clone(),\n        CommitmentConfig::processed(),\n        subscribe_to_raydium\n    ).await;\n\n    subscriber.start_thread().await;\n}\n</code></pre> <p>create sniper/src/oracle/mod.rs</p> <pre><code>pub mod websocket;\n</code></pre> <p>A lot happened here, so let\u2019s break it down and go over it bit by bit.</p> <p>In <code>sniper/src/oracle/websocket.rs</code>, we created a new struct called <code>SolanaSubscriber</code>. In the <code>new</code> method, we simply check whether we can connect to the WSS endpoint from the <code>.env</code> file, or throw an error if that\u2019s not the case. Also, note that in <code>new</code>, we use <code>solana_client::nonblocking::pubsub_client::PubsubClient</code>, where <code>nonblocking</code> is crucial. To maintain speed with many moving parts in our software, we avoid any render-blocking code that could compromise performance and introduce unnecessary delays. Sniping is most efficient down to the millisecond.</p> <p>If we make it past <code>::new</code>, we are good to go and ready to boot up our WebSocket subscriber.</p> <p>Inside the <code>start_thread</code> method, we create a new stream inside a loop that runs indefinitely, keeping our program active until we send an exit signal, such as pressing <code>Ctrl + C</code>. This stream is initialized with <code>subscribe_to</code>, where we provide it the address <code>675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8</code>, the AMM v4 (OpenBook) smart contract address, along with the commitment level 'processed'. This is the earliest stage at which we can discover a new token, but it\u2019s also the most unstable. We might attempt to swap against a token that never actually exists due to issues like an incorrectly filled smart contract, a missing Serum order book, insufficient funds, timeouts, or other problems. We also parse each log received from our subscriber and check if it contains <code>initialize2</code>. While <code>675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8</code> is a legacy address, it is still widely used. Towards the end of this series, we will explore how to use the newest contract to make the sniper future-compatible.</p> <p></p> <p>Terminal output of a running Solana websocket in our program</p> <p>https://solscan.io/tx/7RKF411YTojKv51Yq25ivqnj3HYz2MriNj47bFy73B83RSxrwoUupjWptntf7XKpQSBsGYLrQxcefnBEKsfpoRj https://solscan.io/tx/5JCD9rtXWiHsRCKbNReBcaA7nFVvaaELXkdcSrb6j1U4jYyarG8akVSqPjErq6dGRwmx2USD4zGESrPf7a6dh2R https://solscan.io/tx/4R4vFQAKPapyWUF2khE8Wwe3q75LiyCipa1tJVtshFvVpMWiFjhNmZa9QYribAgRd9zetYnv4zzLvmUACfg4efQf https://solscan.io/tx/Xb2VHwfmHRANsNzsSWXsDyVKw2rdUyg1owvSLGN9GfHNZJZ4VzFWfQEqKt7LD2e2JS5gsuNafNDzNtYkJpPSmG5</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#setting-up-on-a-linode-server","title":"Setting up on a Linode server","text":"<p>Note that the setup script provided below is not production-ready. You should, at the very least, restrict access to the server to only your own IP address and use an ECDSA or RSA key for security. If you do not have experience with server operations, you should consult an expert. The script provided is intended only as a quick starting point for testing in an environment that is close to optimized.</p> <p>I choose Linode because they offer 30GPS internet speed and competitive priced cloud resources, you can also get started with Linode at $100 credit, to try it out.</p> <p></p> <p>Linode starting a VPS</p> <p></p> <p>Linode starting a VPS</p> <p></p> <p>Linode starting a VPS</p> <p>Choose a premium CPU; you do not want to share CPU cores with other instances, as this can degrade performance, especially when sniping. As for the location, I chose it because it is close to Helius.dev\u2019s staked validator, which we will use later on with a staked connection. Other considerations include proximity to a Cloudflare endpoint, as most providers set up their WSS and RPC endpoints to proxy through Cloudflare for better security.</p> <p>ssh into your server and run the prepare_linode.sh</p> <pre><code># Clone the project to get started\ngit clone https://github.com/weestack/Solana-Sniper.git\ncd Solana-Sniper\nbash prepare_linode.sh\nsource ~/.bashrc\n</code></pre> <p>Running <code>bash prepare_linode.sh</code> will install Rust and <code>protoc</code>, which are required. It also replaces the nameserver in <code>resolv.conf</code> with Cloudflare's for lower network latency.</p> <p>when asked which installation type, as the screenshot below, use 1 eg default:</p> <p></p> <p>Accepting default rust installation</p> <p>Now run the below to build the sniper and run it:</p> <pre><code># note if you meet an issue about cargo not existing, run source ~/.bashrc\ncargo build --release\n# Run the sniper\n./target/release/sniper\n</code></pre>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#websocket-comparison","title":"Websocket comparison","text":"<p>For this series, I have compared QuickNode against Helius.dev, both efficient providers in Solana RPC and WSS.</p> <p></p> <p>Helius.dev results</p> <p>[2025\u201301\u201309T02:38:40.223Z sniper::oracle::websocket] [2025\u201301\u201309T02:39:59.082Z sniper::oracle::websocket] [2025\u201301\u201309T02:40:12.299Z sniper::oracle::websocket]</p> <p></p> <p>Quicknode results</p> <p>[2025\u201301\u201309T02:38:40.546Z sniper::oracle::websocket] [2025\u201301\u201309T02:39:59.333Z sniper::oracle::websocket] [2025\u201301\u201309T02:40:12.424Z sniper::oracle::websocket]</p> <p>In the first transaction, Helius was 323ms faster than Quicknode. In the second transaction, Helius was 251ms faster than Quicknode. In the third transaction, Helius was 125ms faster than Quicknode.</p> <p>For the purpose of building an efficient sniper, we will use Helius. However, this is not because their WSS endpoint is faster. To gain a top position, we won\u2019t even be using helius.dev\u2019s WSS endpoint; instead, we will only use their staked RPC endpoint, which costs $49 a month with the developer plan. More about that later.</p> <p>Does the above result mean that Helius.dev is superior to QuickNode? Absolutely not. This was just a quick comparison. Staying ahead of the network is not an easy task, and both providers excel at it. In addition to simple WSS and RPC endpoints, QuickNode also offers a wide range of different API endpoints and services for Solana that would definitely be handy for any Solana developer. Both providers excel in different areas of providing Solana services.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#up-next","title":"Up next","text":"<p>In the next article, we\u2019ll dive deeper into Solana transactions and extract the necessary accounts to perform swapping. Thanks for reading this tutorial! Don\u2019t forget to subscribe so you won\u2019t miss the next part of the series.</p>","tags":["Solana"]},{"location":"blog/2025/01/09/writing-a-raydium-sniper-in-rust-part-2/#disclaimer","title":"Disclaimer","text":"<p>The information provided in this series of articles is for educational purposes only and should not be considered financial or investment advice. Trading, including sniping tokens, carries significant risks, and there is no guarantee of profit.</p> <p>Any decisions you make based on the content shared here are solely your responsibility. I am not liable for any financial losses incurred as a result of implementing the strategies, code, or techniques discussed in these articles.</p> <p>Always trade responsibly. Never risk more money than you can afford to lose. It is essential to conduct your own research and consult with a professional financial advisor if necessary before engaging in any trading activities.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/","title":"Writing a Raydium sniper in Rust part 3","text":"","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#writing-a-raydium-sniper-in-rust-part-3","title":"Writing a Raydium sniper in Rust part 3","text":"<p>This is part three of this series, where we are creating a Solana sniper bot for Raydium from scratch in Rust. See the first post here which includes an introduction about why we use a compiled language instead of JavaScript, as well as prerequisites and a brief introduction about me. You can find the latest GitHub source here, which will be updated with each new post.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#disclaimer","title":"Disclaimer","text":"<p>The information provided in this series of articles is for educational purposes only and should not be considered financial or investment advice. Trading, including sniping tokens, carries significant risks, and there is no guarantee of profit.</p> <p>Any decisions you make based on the content shared here are solely your responsibility. I am not liable for any financial losses incurred as a result of implementing the strategies, code, or techniques discussed in these articles.</p> <p>Always trade responsibly. Never risk more money than you can afford to lose. It is essential to conduct your own research and consult with a professional financial advisor if necessary before engaging in any trading activities.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#what-to-expect-today","title":"What to expect today","text":"<p>Last time, we implemented a websocket watcher that monitors any Raydium `initialize2 transactions. These transactions occur when a new token is minted, making them suitable for sniping.</p> <p>Today, we will explore swap transactions, initialize transactions, and how to extract the information necessary for sniping a token.</p> <p>Apologies for the lengthy explanation \u2014 I know you\u2019re eager to dive into the code. Don\u2019t worry; we\u2019ll get to it later in the article. However, understanding the concepts outlined below is a crucial part of building a sniper.</p> <p>Sure, you can copy-paste the code I provide in the GitHub repo, but the moment something unexpected happens, you probably won\u2019t have a clue how to recover from it.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#transactions","title":"Transactions","text":"<p>Now, let\u2019s start digging into transactions and get a brief overview of how smart contracts work.</p> <p>As you read this, you are probably familiar with sites such as Dexscreener, which monitors on-chain activity. The image below is from Dexscreener, where we will analyze a swap transaction.</p> <p></p> <p>Dexscreener with arrows marking how to see latest meme coins in Raydium</p> <p>I have added a few arrows to demonstrate how I locate the latest Raydium tokens.</p> <p>For example I have chosen the A/SOL token, just a random token:</p> <p></p> <p>Dexscreener A/SOL token graph</p> <p>A lot is happening here, so let\u2019s list the most obvious points:</p> <ul> <li>The market is crazy volatile</li> <li>The first record shows 79 SOL added as liquidity.</li> <li>The second and third transactions are swaps where the token was bought the moment it hit the market.</li> <li>The fourth and fifth transactions seem unusual.   Two users are selling their A tokens, but they are not the same individuals who bought in transactions two and three. What might be happening here?</li> </ul> <p>The market is extremely volatile, and this behavior is best described as a game. For ~99% of all fresh tokens, it\u2019s a quick in-and-out process, as these tokens typically crash within 2 to 20 minutes of launch.</p> <p>To understand what\u2019s happening here, you need to be aware of something called pump.fun. The A/SOL token was not originally launched on Raydium \u2014 it was relaunched there. Raydium allows anyone to create a new token, and if a token gains enough traction, it is relaunched on Raydium. This relaunch uses liquidity generated during the pump.fun phase, which occurs when the bonding curve reaches 100%.</p> <p>There\u2019s much more to learn about this process, but for sniping tokens on Raydium, the specifics of pump.fun are not particularly relevant. I encourage users to explore pump.fun in more depth if they wish to fully understand the entire lifecycle of a token.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#breaking-down-swap-transactions","title":"Breaking down swap transactions","text":"<p>Back to transaction two and three, lets see whats happening there:</p> <ul> <li>Transaction two</li> <li>Transaction three</li> </ul> <p>Lets take transaction two, and break it down into bits, for a deeper understand of whats going on.</p> <p></p> <p>Solana Raydium swap transaction</p> <p>Note: The following might bore the average reader, but understanding the basics of Solana transactions is crucial and the bare minimum for both developing and maintaining a sniper bot. Apart from the points below, every eager sniper developer should thoroughly read Solana\u2019s documentation from start to finish, at least once.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#result","title":"Result","text":"<p>The result covers both the stages and the result itself (Failed/Finalized). We touched on this concept in the previous post, where we discussed the stages: Processed, Confirmed, and Finalized.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#signer","title":"Signer","text":"<p>A signer is the public key associated with your wallet. If you perform a swap transaction through any platform, your public key serves as the signer.</p> <p>There are also cases where smart contracts act as signers. For example, when a token on pump.fun reaches the bonding curve threshold and gets relaunched on Raydium, it is actually a smart contract that signs and moves the funds. This happens because a specific condition has been met.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#fee","title":"Fee","text":"<p>The fee you choose to pay for a transaction is based on the number of compute units consumed. When performing swaps, you will specify a maximum compute unit limit.</p> <p>I encourage you to read the Solana Docs, especially the core sections, as they contain vital information. For example, the lower the compute unit limit you set, the higher the chance your transaction will be processed faster than those with a higher limit. This is because transactions with higher limits might not fit into the current block being proposed.</p> <p>This is critical information for sniping, as it means we should aim to set the smallest possible compute unit limit. However, it\u2019s important not to make it too small, as that would void the transaction. Validators need enough compute units to execute the smart contract and handle the overall instructions in the transaction.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#priority-fee","title":"Priority Fee","text":"<p>This is a fee you can set to increase the chances of your transaction being picked sooner, essentially by tipping your friendly validator. Set it about 5% above the market average. Anything higher is just wasting money, as the effect tends to flatline around 5% to 8%, at least according to my test cases.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#compute-units-consumed","title":"Compute Units Consumed","text":"<p>This is the actual number of compute units consumed by your transaction. Note that there is a limit to how high you can set the compute unit limit: 1.4 million per transaction and 200,000 per instruction. We won\u2019t be working anywhere near those numbers, but anything above those limits will result in an error.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#swap-instruction","title":"Swap instruction","text":"<p>Now lets dig into the swap instruction:</p> <p></p> <p>Solana Raydium swap transaction</p> <p>Note i skipped a lot of instructions such as creating Account with seed, initialize Account, transfers and so on, majority of these will be covered when we learn how to wrap sol. Instead we will focus on</p> <p><code>#6 - Raydium Liquidity Pool V4: raydium:swap</code></p> <p>The source code to the smart contract can be found here: https://github.com/raydium-io/raydium-amm/tree/master</p> <p>A Solana smart contract is an on-chain program written in Rust, (Less common C, or C++) that executes specific logic based on predefined rules. They are stateless and handle only the logic, while the data is managed through accounts.</p> <p>In other words, accounts and an instruction go in, the smart contract works behind the scenes, and in our case \u2014 voil\u00e0! \u2014 we\u2019ve made a swap of a brand-new token released only seconds ago.</p> <p>Now, let\u2019s break the swap transaction into chunks:</p> <ul> <li>Input Account 1   This is simply the Solana token program, which is used to create most new tokens. Regarding meme coins, I\u2019ve never seen any other program used, so it\u2019s safe to say this is always static.</li> <li>Input Accounts 2\u20137    These are Raydium-specific accounts. I encourage readers to read up on and understand what each account does. For the purpose of swapping, we just need to know these accounts exist and match them, as the smart contract handles all the heavy lifting.</li> <li>Input Accounts 10\u201315   These represent the order books, essentially detailing the inflow and outflow. One such order book could be Openbook.</li> <li>Accounts 8 and 9   Are particularly important, while the rest are PDA (Program Derived Addresses), which can be quickly derived.</li> <li>Input Accounts 16\u201318   These are our accounts: </li> <li> <ul> <li>#16: The token account we\u2019re using to input funds for buying A/SOL.</li> </ul> </li> <li> <ul> <li>#17: The address where we will receive the A tokens.</li> </ul> </li> <li> <ul> <li>#18: Our public key, which identifies our wallet.</li> </ul> </li> </ul> <p>Our wallet\u2019s private key holds authority over both #16 and #17.</p> <p></p> <p>Solana A/SOl swap transaction input</p> <p>The smart contract processes specific inputs to execute the swap:</p> <ul> <li>Discriminator: This determines which part of the program to run. In this case, the number 9 is input to trigger a swap. If we input 7, the swap wouldn\u2019t occur. To understand what would happen, you could analyze the smart contact source code</li> <li>amountIn: The amount of the payment token we are providing.</li> <li>minimumAmountOut: This translates to our slippage tolerance. We can take the lazy route and set it to 0, essentially allowing any slippage. Alternatively, we can calculate the expected output and set this value to be 5% lower, effectively allowing a 5% slippage.</li> </ul>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#initialize2-transaction","title":"Initialize2 transaction","text":"<p>Now let\u2019s take a look at the initialize2 transaction for A to see what information we can extract for our swap instruction and what we still need.</p> <ul> <li>Initialize2 instruction for A/SOL</li> </ul> <p></p> <p>Solana A/SOl Initialize2 instruction</p> <p>Does that look familiar? It should! Here\u2019s a breakdown of the input accounts:</p> <ul> <li>Input Accounts 5\u20138 + 11\u201314: These correspond to the Raydium AMM accounts.</li> <li>Input Accounts 9 + 10: These represent the input token and output token (e.g., SOL and A).</li> <li>Input Accounts 16\u201317: These correspond to the Serum program and market. That\u2019s all we need to execute a swap. Yay!</li> </ul>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#lets-get-coding","title":"Lets get coding","text":"<p>Last time, we obtained the signature for the initialize2 transactions from our WebSocket stream. Now, after that long (but crucial!) schooling session of text, let\u2019s use RPC to fetch the transaction and parse the accounts.</p> <p>First, let\u2019s update utils/Cargo.toml with the latest requirements for nonblocking RPC, public key handling, and Solana's built-in transaction structures and implementations. Add the following dependencies to your project:</p> <ul> <li><code>solana-transaction-status</code></li> <li><code>solana-client</code></li> <li><code>solana-sdk</code></li> <li><code>tokio</code></li> </ul> <pre><code>[dependencies]\ndotenv = { workspace = true }\nthiserror = { workspace = true }\nsolana-transaction-status = { workspace = true}\nsolana-client = { workspace = true }\nsolana-program = { workspace = true }\nsolana-sdk = { workspace = true }\nenv_logger = { workspace = true }\nlog = { workspace = true }\ntokio = { workspace = true }\n</code></pre> <p>Create the file utils/src/raydium/initialize2.rs and add the following content</p> <pre><code>use solana_sdk::pubkey;\nuse solana_sdk::pubkey::Pubkey;\nuse solana_sdk::transaction::VersionedTransaction;\nuse std::fmt;\nuse log::info;\nuse solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_client::rpc_config::RpcTransactionConfig;\nuse solana_sdk::commitment_config::CommitmentConfig;\nuse solana_sdk::signature::Signature;\nuse solana_transaction_status::UiTransactionEncoding;\n\npub struct RaydiumInitialize2Transaction {\n    token_program: Pubkey,\n    spl_associated_token_account: Pubkey,\n    system_program: Pubkey,\n    rent_program: Pubkey,\n    amm: Pubkey,\n    amm_authority: Pubkey,\n    amm_open_orders: Pubkey,\n    lp_mint: Pubkey,\n    coin_mint: Pubkey,\n    pc_mint: Pubkey,\n    pool_coin_token_account: Pubkey,\n    pool_pc_token_account: Pubkey,\n    pool_withdraw_queue: Pubkey,\n    amm_target_orders: Pubkey,\n    pool_temp_lp: Pubkey,\n    serum_program: Pubkey,\n    serum_market: Pubkey,\n    user_wallet: Pubkey,\n    user_token_coin: Pubkey,\n    user_token_pc: Pubkey,\n    user_lp_token_account: Pubkey,\n}\n\n#[derive(Debug)]\npub enum RaydiumTransactionError {\n    NotEnoughKeys,\n    CantFindTokenAddress,\n    NoTransactionFound,\n    CouldNotParseTransaction,\n}\n\nimpl RaydiumInitialize2Transaction {\n\n    pub async fn get_transaction(tx: Signature, rpc_endpoint: String) -&gt; Result&lt;RaydiumInitialize2Transaction, RaydiumTransactionError&gt; {\n        let client =\n            RpcClient::new_with_commitment(rpc_endpoint, CommitmentConfig::processed());\n\n        let config = RpcTransactionConfig {\n            encoding: Some(UiTransactionEncoding::Binary),\n            commitment: Some(CommitmentConfig::confirmed()),\n            max_supported_transaction_version: Some(2),\n        };\n        let transaction = client\n            .get_transaction_with_config(&amp;tx, config)\n            .await\n            .map_err(|_| RaydiumTransactionError::NoTransactionFound)?;\n\n        if let Some(versioned_transaction) = transaction.transaction.transaction.decode() {\n            return RaydiumInitialize2Transaction::parse(&amp;versioned_transaction)\n        }\n\n        Err(RaydiumTransactionError::CouldNotParseTransaction)\n    }\n    pub fn parse(transaction: &amp;VersionedTransaction) -&gt; Result&lt;Self, RaydiumTransactionError&gt; {\n        let keys = transaction.message.static_account_keys();\n        if keys.len() != 22 {\n            return Err(RaydiumTransactionError::NotEnoughKeys);\n        }\n\n        // Use to debug the order of the keys inputted, if something seems off\n        /* for (index, solana_address) in keys.iter().enumerate() {\n            debug!(\"{}: {}\", index, solana_address);\n        } */\n\n        /* eval token addresses */\n        let base_coin;\n        let token_coin;\n\n        if keys[13].to_string() == \"So11111111111111111111111111111111111111112\" {\n            base_coin = pubkey!(\"So11111111111111111111111111111111111111112\");\n            token_coin = keys[18];\n        } else if keys[18].to_string() == \"So111111111111111111111111111111111111111111\" {\n            base_coin = pubkey!(\"So11111111111111111111111111111111111111112\");\n            token_coin = keys[13];\n        } else {\n            return Err(RaydiumTransactionError::CantFindTokenAddress);\n        }\n\n        Ok(RaydiumInitialize2Transaction {\n            token_program: keys[12],\n            spl_associated_token_account: keys[16],\n            system_program: keys[11],\n            rent_program: keys[14],\n            amm: keys[2],\n            amm_authority: keys[17],\n            amm_open_orders: keys[3],\n            lp_mint: keys[4],\n            coin_mint: base_coin,\n            pc_mint: token_coin,\n            pool_coin_token_account: keys[5],\n            pool_pc_token_account: keys[6],\n            pool_withdraw_queue: keys[7],\n            amm_target_orders: keys[19],\n            pool_temp_lp: keys[8],\n            serum_program: keys[20],\n            serum_market: keys[21],\n            user_wallet: keys[0],\n            user_token_coin: keys[1],\n            user_token_pc: keys[9],\n            user_lp_token_account: keys[10],\n        })\n    }\n\n    pub fn get_mint(&amp;self) -&gt; Pubkey {\n        self.pc_mint\n    }\n}\n\nimpl fmt::Display for RaydiumInitialize2Transaction {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(\n            f,\n            \"token_program:                {}\nspl_associated_token_account: {}\nsystem_program:               {}\nrent_program:                 {}\namm:                          {}\namm_authority:                {}\namm_open_orders:              {}\nlp_mint:                      {}\ncoin_mint:                    {}\npc_mint:                      {}\npool_coin_token_account:      {}\npool_pc_token_account:        {}\npool_withdraw_queue:          {}\namm_target_orders:            {}\npool_temp_lp:                 {}\nserum_program:                {}\nserum_market:                 {}\nuser_wallet:                  {}\nuser_token_coin:              {}\nuser_token_pc:                {}\nuser_lp_token_account:        {}\",\n            self.token_program,\n            self.spl_associated_token_account,\n            self.system_program,\n            self.rent_program,\n            self.amm,\n            self.amm_authority,\n            self.amm_open_orders,\n            self.lp_mint,\n            self.coin_mint,\n            self.pc_mint,\n            self.pool_coin_token_account,\n            self.pool_pc_token_account,\n            self.pool_withdraw_queue,\n            self.amm_target_orders,\n            self.pool_temp_lp,\n            self.serum_program,\n            self.serum_market,\n            self.user_wallet,\n            self.user_token_coin,\n            self.user_token_pc,\n            self.user_lp_token_account\n        )\n    }\n}\n</code></pre> <p>Whew, that\u2019s a lot of code! Let\u2019s break it down into chunks to thoroughly understand each part.</p> <pre><code>pub struct RaydiumInitialize2Transaction {\n    token_program: Pubkey,\n    spl_associated_token_account: Pubkey,\n    system_program: Pubkey,\n    rent_program: Pubkey,\n    amm: Pubkey,\n    amm_authority: Pubkey,\n    amm_open_orders: Pubkey,\n    lp_mint: Pubkey,\n    coin_mint: Pubkey,\n    pc_mint: Pubkey,\n    pool_coin_token_account: Pubkey,\n    pool_pc_token_account: Pubkey,\n    pool_withdraw_queue: Pubkey,\n    amm_target_orders: Pubkey,\n    pool_temp_lp: Pubkey,\n    serum_program: Pubkey,\n    serum_market: Pubkey,\n    user_wallet: Pubkey,\n    user_token_coin: Pubkey,\n    user_token_pc: Pubkey,\n    user_lp_token_account: Pubkey,\n}\n</code></pre> <p>We create a new struct to hold the accounts in the <code>Initialize2</code> transaction. Not all accounts are necessary for swapping, but if you want to expand the functionality later, the <code>user_wallet</code> could be important for features like copy trading. The same goes for the standard programs used. I\u2019ve included them here to provide easier flexibility for future development.</p> <p>After that we implement two new functions for our struct get_transaction, and parse,</p> <p><code>get_transaction</code></p> <pre><code>pub async fn get_transaction(tx: Signature, rpc_endpoint: String) -&gt; Result&lt;RaydiumInitialize2Transaction, RaydiumTransactionError&gt; {\n    let client =\n        RpcClient::new_with_commitment(rpc_endpoint, CommitmentConfig::processed());\n\n    let config = RpcTransactionConfig {\n        encoding: Some(UiTransactionEncoding::Binary),\n        commitment: Some(CommitmentConfig::processed()),\n        max_supported_transaction_version: Some(2),\n    };\n    let transaction = client\n        .get_transaction_with_config(&amp;tx, config)\n        .await\n        .map_err(|_| RaydiumTransactionError::NoTransactionFound)?;\n\n    if let Some(versioned_transaction) = transaction.transaction.transaction.decode() {\n        return RaydiumInitialize2Transaction::parse(&amp;versioned_transaction)\n    }\n\n    Err(RaydiumTransactionError::CouldNotParseTransaction)\n}\n</code></pre> <p>We use Solana\u2019s <code>RpcClient</code>, specifically the non-blocking version. This is crucial because, later on, we will delve deeper into async behavior to decouple certain processes and distribute them across multiple CPU cores.</p> <p>Next, we create an <code>RpcTransactionConfig</code>, where we request binary encoding and a processed commitment. If we successfully find the transaction, we retrieve it using <code>client.get_transaction_with_config</code>. If the transaction is not found, the function will simply halt and return control back to the WebSocket stream, which will continue looking for new <code>initialize2</code> transactions.</p> <p>Finally, we decode the transaction into a <code>versioned_transaction</code> and pass it to our <code>parse</code> function.</p> <p><code>Parse</code></p> <pre><code>pub fn parse(transaction: &amp;VersionedTransaction) -&gt; Result&lt;Self, RaydiumTransactionError&gt; {\n    let keys = transaction.message.static_account_keys();\n    if keys.len() != 22 {\n        return Err(RaydiumTransactionError::NotEnoughKeys);\n    }\n\n    // Use to debug the order of the keys inputted, if something seems off\n    /* for (index, solana_address) in keys.iter().enumerate() {\n        debug!(\"{}: {}\", index, solana_address);\n    } */\n\n    /* eval token addresses */\n    let base_coin;\n    let token_coin;\n    if keys[13].to_string() == \"So11111111111111111111111111111111111111112\" {\n        base_coin = pubkey!(\"So11111111111111111111111111111111111111112\");\n        token_coin = keys[18];\n    } else if keys[18].to_string() == \"So111111111111111111111111111111111111111111\" {\n        base_coin = pubkey!(\"So11111111111111111111111111111111111111112\");\n        token_coin = keys[13];\n    } else {\n        return Err(RaydiumTransactionError::CantFindTokenAddress);\n    }\n\n    Ok(RaydiumInitialize2Transaction {\n        token_program: keys[12],\n        spl_associated_token_account: keys[16],\n        system_program: keys[11],\n        rent_program: keys[14],\n        amm: keys[2],\n        amm_authority: keys[17],\n        amm_open_orders: keys[3],\n        lp_mint: keys[4],\n        coin_mint: base_coin,\n        pc_mint: token_coin,\n        pool_coin_token_account: keys[5],\n        pool_pc_token_account: keys[6],\n        pool_withdraw_queue: keys[7],\n        amm_target_orders: keys[19],\n        pool_temp_lp: keys[8],\n        serum_program: keys[20],\n        serum_market: keys[21],\n        user_wallet: keys[0],\n        user_token_coin: keys[1],\n        user_token_pc: keys[9],\n        user_lp_token_account: keys[10],\n    })\n}\n</code></pre> <p>We extract the accounts from the transaction and verify that it contains exactly 22 accounts. We also check that an SPL token, such as WSOL, is used. There are different ways to create a token on Raydium, so we perform minimal validation to ensure the input matches the expected format. While more extensive validation could (and probably should) be implemented, every millisecond counts, so we keep it minimal\u2014especially since this is a core route from discovering to sniping a token.Finally we also implement fmt::Display, this is simply to control the output when we print or log our initialize2 struct.</p> <p></p> <p>CLI output of token addresses</p> <p>Create the file utils/src/raydium/mod.rs with the below line</p> <pre><code>pub mod initialize2;\n</code></pre> <p>Add the new module raydium to utils/src/lib.rs</p> <pre><code>pub mod raydium;\n</code></pre> <p>Let\u2019s update the <code>start_thread</code> function in <code>sniper/src/oracle/websocket.rs</code> to use the new transaction parser. We will modify the function as follows:</p> <pre><code>pub async fn start_thread(&amp;self) {\n        info!(\"Starting Solana websocket subscriber\");\n        let subscribe_to = self.subscribe_to.clone();\n        let config_level = self.config_level.clone();\n        let rpc_endpoint = self.rpc_endpoint.clone();\n        let (mut stream, _) = self.client.logs_subscribe(\n            RpcTransactionLogsFilter::Mentions(\n                subscribe_to\n            ),\n            RpcTransactionLogsConfig {\n                commitment: Some(config_level),\n            }\n        ).await.expect(\"Failed to subscribe to Logs!\");\n\n        info!(\"Waiting for next event\");\n        while let Some(response) = stream.next().await {\n\n            for log in &amp;response.value.logs {\n                /* skip all events that does not contain initialize2 eg token create */\n                if !log.contains(\"initialize2\") {\n                    continue\n                }\n                {\n                    let tx = Signature::from_str(response.value.signature.as_str()).unwrap();\n                    info!(\"Received tx https://solscan.io/tx/{}\", tx);\n                    let transaction = RaydiumInitialize2Transaction::get_transaction(tx, rpc_endpoint.clone()).await;\n\n                    if transaction.is_err() {\n                        info!(\"Failed to get transaction\");\n                    } else {\n                        let initialize2_transaction = transaction.unwrap();\n                        info!(\"====={}=====\\r\\n{}\", initialize2_transaction.get_mint(), initialize2_transaction);\n                    }\n                }\n            }\n        }\n</code></pre> <p>Notice the</p> <pre><code>let transaction = RaydiumInitialize2Transaction::get_transaction(tx, rpc_endpoint.clone()).await;\n\nif transaction.is_err() {\n    info!(\"Failed to get transaction\");\n} else {\n    let initialize2_transaction = transaction.unwrap();\n    info!(\"====={}=====\\r\\n{}\", initialize2_transaction.get_mint(), initialize2_transaction);\n}\n</code></pre> <p>Here, we simply call our new <code>get_transaction</code> method. If the transaction is ready, we print it to ensure that we have everything needed for the swap transaction.</p> <p>Update sniper/Cargo.toml with <code>solana-sdk</code> and <code>solana-transaction-status</code> dependencies</p> <pre><code>[...]\n[dependencies]\nutils = { workspace = true }\nsolana-client = { workspace = true }\nsolana-sdk = { workspace = true}\ntokio = { workspace = true }\nfutures = { workspace = true }\nlog = { workspace = true }\n</code></pre> <p>Thats it, lets take it for at test run!</p> <p></p> <p>CLI output of token addresses with ms timings</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#stability","title":"Stability","text":"<p>Is the current method stable? Not quite. We use \u201cProcessed\u201d in both the WebSocket stream and RPC transaction fetch, but the RPC often lags behind the WebSocket stream, causing the program to fail. There are several ways to mitigate this, though none are covered in this article. You could set the commitment status to \u201cConfirmed\u201d and discover it a second later, or retry for a few seconds before aborting.</p>","tags":["Solana"]},{"location":"blog/2025/01/20/writing-a-raydium-sniper-in-rust-part-3/#up-next","title":"Up next","text":"<p>In the next article, we will look into how to change our SOL to WSOL, which is needed for swapping, we will do this with a command line layer.</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/","title":"Writing a Raydium sniper in Rust part 4","text":"","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#writing-a-raydium-sniper-in-rust-part-4","title":"Writing a Raydium sniper in Rust part 4","text":"<p>This is part four of this series, where we are creating a Solana sniper bot for Raydium from scratch in Rust. See the first post here which includes an introduction about why we use a compiled language instead of JavaScript, as well as prerequisites and a brief introduction about me. You can find the latest GitHub source here, which will be updated with each new post.  </p> <p>Solana needs to be wrapped for most meme coin swaps, but is there another reason for this command?</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#disclaimer","title":"Disclaimer","text":"<p>The information provided in this series of articles is for educational purposes only and should not be considered financial or investment advice. Trading, including sniping tokens, carries significant risks, and there is no guarantee of profit.</p> <p>Any decisions you make based on the content shared here are solely your responsibility. I am not liable for any financial losses incurred as a result of implementing the strategies, code, or techniques discussed in these articles.</p> <p>Always trade responsibly. Never risk more money than you can afford to lose. It is essential to conduct your own research and consult with a professional financial advisor if necessary before engaging in any trading activities.</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#what-to-expect-today","title":"What to expect today","text":"<p>Last time, we explored swap and initialization transactions, delving deeper into how to extract actionable data from Solana's blockchain for efficient token sniping. This includes identifying transaction patterns.</p> <p>Today, we will learn how to build our own CLI command to wrap SOL to wSOL, the common currency for swapping meme coins. Additionally, we will have a short discussion on transaction optimization.</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#wrapped-solana","title":"Wrapped Solana","text":"<p>The first question that might come to mind is: why do I need to wrap my Solana, and what does it even mean to wrap it?</p> <p>Solana (SOL) is the native token of the Solana blockchain, used for gas fees and staking. wSOL, however, is an SPL token with the exact same value as SOL. Just like any meme coin is created as an SPL token, wSOL is also created using Solana's SPL token program.</p> <p>Holding SOL in the form of wSOL means you are always ready to trade without needing to add extra instructions for wrapping your SOL when a new meme coin is released.</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#creating-a-cli-command","title":"Creating a cli command","text":"<p>Now that we\u2019ve covered the basics, let's create a CLI command to convert our regular, boring SOL into hot-swappable wSOL.</p> <p>Create a new package with</p> <p><pre><code>cargo new shell\n</code></pre> Create the following files: <pre><code>shell/Cargo.toml\nshell/src/main.rs\nshell/src/commands/mod.rs\nshell/src/wrap_sol.rs\n</code></pre></p> <p>With that, we have created all the files needed for the wrap SOL command we are going to build.</p> <p>Fill <code>shell/Cargo.toml</code> with</p> <pre><code>[package]\nname = \"shell\"\nauthors.workspace = true\nedition.workspace = true\nhomepage.workspace = true\nrepository.workspace = true\nlicense.workspace = true\nkeywords.workspace = true\nversion.workspace = true\nreadme.workspace = true\ncategories.workspace = true\npublish.workspace = true\n\n[dependencies]\nclap = { workspace = true }\nutils = { workspace = true }\nsolana-client = { workspace = true }\nsolana-sdk = { workspace = true }\nspl-token-client = { workspace = true }\nspl-token = { workspace = true }\ntokio = { workspace = true }\n\n[lints]\nworkspace = true\n</code></pre> <p>We have added <code>clap</code>, a common Rust library for creating CLI commands, which provides an easy syntax for defining command-line arguments directly from structs and supports hinting.</p> <p>In addition to <code>clap</code> we have also introduced the <code>spl-token-client</code> and <code>spl-token</code> libraries, which are used for wrapping SOL to wSOL. </p> <p>Fill <code>shell/src/main.rs</code> with</p> <pre><code>mod commands;\nuse commands::wrap_sol::WrapArgs;\nuse clap::{Parser, Subcommand};\nuse solana_sdk::native_token::LAMPORTS_PER_SOL;\nuse utils::env::env::Env;\nuse crate::commands::wrap_sol;\n\n#[derive(Debug, Parser)] // requires `derive` feature\n#[command(name = \"Solana Commands\")]\n#[command(about = \"CLI solana commands\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands\n}\n\n#[derive(Clone, Debug, Subcommand)]\nenum Commands {\n    WrapSol(WrapArgs),\n}\n\n#[tokio::main]\nasync fn main() {\n    let env = Env::new().unwrap();\n    let cli_command = Cli::parse();\n\n    match cli_command.command {\n        Commands::WrapSol(wrap_args) =&gt; {\n            let amount = (wrap_args.amount as f64 * LAMPORTS_PER_SOL as f64) as u64;\n\n            wrap_sol::wrap_sol_fn(\n                amount,\n                &amp;env.private_key,\n                env.rpc_endpoint.to_string(),\n            ).await\n        }\n    }\n}\n</code></pre> <p>A lot happens in the 37 lines of code above in <code>main.rs</code>, so lets break it down:</p> <ul> <li>At line 9, we define our shell and name it Solana Commands.</li> <li>At line 10, we provide a short description.</li> <li>From lines 11 to 14, we create the actual struct for the command shell, which takes in an <code>Enum Commands</code> At lines 17 to 19, we define our first command, <code>WrapSol</code> with the arguments <code>WrapArgs</code> we will cover in another file. <code>clap</code> automatically parses <code>WrapSol</code> as <code>wrap-sol</code>, enabling us to run the shell command: <code>cargo run wrap-sol</code></li> </ul> <p></p> <p>CLI output of running <code>cargo run shell</code></p> <p>The great thing about this layout is that if you wanted to create additional commands, you would simply add a new enum variant to <code>Commands. You could then call it using:</code>cargo run shell ` and handle it within main.rs using pattern matching.   <ul> <li>From lines 26 to 36, we implement a simple match statement to handle WrapSol when it is passed as a command-line argument.</li> </ul> <p>Fill <code>shell/src/commands/mod.rs</code> with</p> <pre><code>pub mod wrap_sol;\n</code></pre> <p>We are making wrap_sol public so that it can be called elsewhere.</p> <p>Fill <code>shell/src/commands/mod.rs</code> with</p> <pre><code>use std::sync::Arc;\nuse solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_sdk::signature::{Keypair};\nuse solana_sdk::signer::Signer;\nuse solana_sdk::transaction::Transaction;\nuse spl_token_client::client::{ProgramClient, ProgramRpcClient, ProgramRpcClientSendTransaction};\nuse spl_token_client::token::Token;\n\n#[derive(Debug, clap::Args, Clone)]\npub struct WrapArgs {\n    #[arg(\n            long,\n    )]\n    pub amount: f32,\n}\n\nfn rpc(rpc_endpoint: String) -&gt; Arc&lt;RpcClient&gt; {\n    Arc::new(RpcClient::new(rpc_endpoint.to_string()))\n}\nfn program_rpc(rpc: Arc&lt;RpcClient&gt;) -&gt; Arc&lt;dyn ProgramClient&lt;ProgramRpcClientSendTransaction&gt;&gt; {\n    let program_client: Arc&lt;dyn ProgramClient&lt;ProgramRpcClientSendTransaction&gt;&gt; = Arc::new(\n        ProgramRpcClient::new(rpc.clone(), ProgramRpcClientSendTransaction),\n    );\n    program_client\n}\n\nfn keypair_clone(kp: &amp;Keypair) -&gt; Keypair {\n    Keypair::from_bytes(&amp;kp.to_bytes()).expect(\"failed to copy keypair\")\n}\n\npub async fn wrap_sol_fn(wrap_amount: u64, keypair: &amp;Arc&lt;Keypair&gt;, rpc_endpoint: String) {\n    let wsol_wrap_amount: u64 = wrap_amount;\n    let client = rpc(rpc_endpoint);\n    let program_client = program_rpc(Arc::clone(&amp;client));\n\n    /* prepare the wSOL account */\n    let in_token_client = Token::new(\n        Arc::clone(&amp;program_client),\n        &amp;spl_token::ID,\n        &amp;spl_token::native_mint::id(),\n        None,\n        Arc::new(keypair_clone(&amp;keypair)),\n    );\n\n    let user_in_token_account = in_token_client.get_associated_token_address(&amp;keypair.pubkey());\n    let wsol_acc_exists = in_token_client\n        .get_account_info(&amp;user_in_token_account)\n        .await;\n\n    /* ensure wsol token program has not been closed! */\n    if wsol_acc_exists.is_err() {\n        in_token_client.create_associated_token_account(\n            &amp;keypair.pubkey()\n        ).await.unwrap();\n    }\n\n    let user_in_acct = in_token_client\n        .get_account_info(&amp;user_in_token_account)\n        .await.unwrap();\n\n    let balance = user_in_acct.base.amount;\n    if in_token_client.is_native() &amp;&amp; balance &lt; wsol_wrap_amount {\n        let transfer_amt = wsol_wrap_amount - balance;\n        let blockhash = client.get_latest_blockhash().await.unwrap();\n        let transfer_instruction = solana_sdk::system_instruction::transfer(\n            &amp;keypair.pubkey(),\n            &amp;user_in_token_account,\n            transfer_amt,\n        );\n        let sync_instruction =\n            spl_token::instruction::sync_native(&amp;spl_token::ID, &amp;user_in_token_account).unwrap();\n        let tx = Transaction::new_signed_with_payer(\n            &amp;[transfer_instruction, sync_instruction],\n            Some(&amp;keypair.pubkey()),\n            &amp;[&amp;keypair],\n            blockhash,\n        );\n\n        let signature = client.send_transaction(&amp;tx).await.unwrap();\n        println!(\"signature {signature:?}\");\n    }\n}\n</code></pre> <p>A lot happened again, so let's go over it step by step.  </p> <p>Lines 9 to 15 define the `WrapArgs struct, which takes a float as an argument to specify how much SOL to wrap into wSOL.</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#wsol-transaction","title":"WSOL transaction","text":"<p>Now, let's break down the instructions from lines 32 to 80.</p> <p><pre><code>/* prepare the wSOL account */\nlet in_token_client = Token::new(\n    Arc::clone(&amp;program_client),\n    &amp;spl_token::ID,\n    &amp;spl_token::native_mint::id(),\n    None,\n    Arc::new(keypair_clone(&amp;keypair)),\n);\n</code></pre> Lines 37 to 43: We simply create a struct with the necessary information for the functions used later.</p> <p><pre><code>let user_in_token_account = in_token_client.get_associated_token_address(&amp;keypair.pubkey());\nlet wsol_acc_exists = in_token_client\n    .get_account_info(&amp;user_in_token_account)\n    .await;\n</code></pre> Line 45: We check if we can derive our wSOL account address and in lines 46 to 48: We fetch that address.</p> <p><pre><code>/* ensure wsol token program has not been closed! */\nif wsol_acc_exists.is_err() {\n    in_token_client.create_associated_token_account(\n        &amp;keypair.pubkey()\n    ).await.unwrap();\n}\n</code></pre> Lines 51 to 55: We create the wSOL address if it does not already exist.</p> <p><pre><code>let user_in_acct = in_token_client\n    .get_account_info(&amp;user_in_token_account)\n    .await.unwrap();\n</code></pre> Line 57: We fetch our SOL account address.</p> <p>That wasn\u2019t so bad, right? \ud83d\ude09</p> <p>The remainder of the code simply handles the amount, signing, and actually sending the transaction. It then prints the transaction signature so we can look it up on-chain using sites like solana.fm and solscan.io.  </p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#adding-private-key-to-environment-variables","title":"Adding Private Key to Environment Variables","text":"<p>A word of caution:</p> <p>While researching how to build my own Solana sniper, I reviewed numerous codebases, and almost all had one thing in common\u2014they were malicious honeypots designed to steal unsuspecting victims' private keys and drain their entire SOL balance.  Always be extremely careful with the code you execute and where you store your private key. Even better, make sure you understand each line of the code before running any program that involves your private key.</p> <p>The final step for wrapping SOL is to add our private key to our environment variables (env) so it can be used for signing and approving transactions in the <code>wrap-sol</code> command.</p> <p>Update <code>pub fn new()</code> in <code>utils/src/env/env.rs</code> to</p> <pre><code>pub fn new() -&gt; Result&lt;Self, EnvErrors&gt; {\n// Test if .env exists or give the option to create one from .env.dist\nlet path = Path::new(\".env\");\nif ! path.exists() {\n    println!(\"Could not find .env, would you like to use .env.dist as a template instead? (y/n)\");\n    create_env().expect(\"Failed creating .env file\");\n}\ndotenv::from_path(\".env\").ok();\n\nlet loglevel = Arc::new(parse_log_level(env::var(\"LOG_LEVEL\")?));\n\nlet websocket_endpoint = Arc::new(env::var(\"WEBSOCKET_ENDPOINT\")?);\nlet rpc_endpoint = Arc::new(env::var(\"RPC_ENDPOINT\")?);\n\nlet private_key_path = env::var(\"PRIVATE_KEYPAIR\")?;\nlet private_key = Arc::new(Keypair::read_from_file(private_key_path).unwrap());\n\nlet swap_amount = Arc::new(env::var(\"SWAP_AMOUNT\")?.parse::&lt;u64&gt;().unwrap());\nlet swap_priority_fee = Arc::new(env::var(\"SWAP_PRIORITY_FEE\")?.parse::&lt;u64&gt;().unwrap());\n\nOk(\n    Self {\n        loglevel,\n        websocket_endpoint,\n        rpc_endpoint,\n        private_key,\n        swap_amount,\n        swap_priority_fee,\n    }\n)\n}\n</code></pre> <p>Lines 15 to 16 read the <code>PRIVATE_KEYPAIR</code> directive from the .env file and load the private keypair into memory.</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#test-run","title":"Test run","text":"<p>With all that set up, let's test it out on the devnet and see if it works.</p> <p>Before using your own private key, let's run a simple test on the Solana devnet using a newly generated random keypair and observe the results.</p> <p>Be careful not to overwrite your current private key with this command unless you have a backup.</p> <pre><code># Create a new key called private_key.json\nsolana-keygen new -o private_key.json\n\n# Switch default config to use devnet\nsolana config set --url https://api.devnet.solana.com\n\n# Get the public key of your wallet mine was 3Vy1sD9fwzUv6npTE8qM2o4DJGRRXdLryhyKfmjZByGu\nsolana-keygen pubkey private_key.json\n\n# Request an airdrop with fake SOL on the devnet\nsolana airdrop 2 3Vy1sD9fwzUv6npTE8qM2o4DJGRRXdLryhyKfmjZByGu\n</code></pre> <p>Lastly, edit the .env file and add or replace this line: <code>PRIVATE_KEYPAIR=private_key.json</code> Also, set the RPC_ENDPOINT to devnet while we are testing: <code>RPC_ENDPOINT=https://api.devnet.solana.com</code></p> <p>Once you have executed the commands from the previous steps, you should be all set to wrap some SOL into wSOL!</p> <p></p> <p>Solana.fm with my wallet</p> <p>Lets execute <pre><code>cargo run --bin shell wrap-sol --amount 0.2\n</code></pre> so we exchange 0.2 SOL for 0.2 WSOL. </p> <p>Executing wSOL wrap command</p> <p>As you can see, I got the signature.</p> <p>If you get this error, it likely means you either forgot to change the RPC_ENDPOINT to devnet or did not successfully receive the 2 SOL airdrop.</p> <p></p> <p>Error wrapping sol</p> <p>Great! Now, how do we confirm that the SOL was actually wrapped and not just burned?  Navigate to my wallet to check.</p> <p></p> <p>Displaying wrapped sol</p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#why-are-we-wrapping-sol-in-a-command","title":"Why are we wrapping sol in a command?","text":"<p>We are wrapping SOL in a command because each instruction in a transaction increases computational usage (measured in compute units or CUs). The more CUs a transaction consumes, the less likely it is to be processed quickly.</p> <p>Solana is designed to fit as many transactions as possible into a single block. Once a block is nearly full, some transactions will have to wait for the next block. However, if your swap transaction is small enough, it has a higher chance of being included faster potentially ahead of other, larger transactions that might be skipped. </p>","tags":["Solana"]},{"location":"blog/2025/03/12/writing-a-raydium-sniper-in-rust-part-4/#up-next","title":"Up next","text":"<p>In the next article, we will look into how to change our SOL to WSOL, which is needed for swapping, we will do this with a command line layer.</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/","title":"Writing a Raydium sniper in Rust","text":"","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#writing-a-solana-raydium-sniper-in-rust","title":"Writing a Solana Raydium sniper in Rust","text":"<p>If sniping positions are important to you, Rust or any compiled language is essential for peeling off every possible millisecond. This stands in contrast to the more traditional sniping language, JavaScript, which is interpreted and therefore inherently slower than a compiled language.</p> <p>This is a story about how I discovered sites like Dexscreener, stayed up all night trying to turn a profit on those impressive +10,000% gain tokens through manual trades, and eventually ended up coding my own sniper. Starting with Python and later transitioning to Rust, I was able to consistently rank among the top 10 snipes for any new AMM token on Raydium.</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#what-to-expect","title":"What to expect","text":"<p>This series of articles will be released as I find time to write them. After each release, I will update the associated GitHub repository here, with the latest code. This also means, the sniper will be released in small chunks.</p> <p>So, when will it all be available? Honestly, I don\u2019t know yet. Ideas often evolve over time, and while I already have the final code in a private repository, I might come up with improvements or ways to make it more user-friendly as this series progresses.</p> <p>I\u2019m not a Rust expert, I\u2019ve only been working with the language for a little over six months. I initially learned Rust with the goal of building my Solana sniper bot. Since then, I\u2019ve developed a passion for the language and have started using it for various other projects.</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#about-me","title":"About me","text":"<p>By now, you might be wondering about my experience as a programmer, so here\u2019s a brief (and maybe slightly boring) overview. \ud83d\ude09</p> <p>I am a Senior DevOps Engineer in my early thirties. I started with Linux hosting at the age of 15 and, by 25, had freelanced for over 80 companies across Denmark, Norway, and the USA, specializing in e-commerce and operations. Today, I work full-time as a Senior DevOps Engineer, contributing to some of Denmark\u2019s largest e-commerce ventures. My responsibilities include serving as a tech lead on large projects, mentoring new developers, and managing operations and security for over 100 dedicated servers and numerous cloud instances.</p> <p>In 2024, I became captivated by the world of crypto and quickly immersed myself in quantitative trading. I turned a profit using strategies like RSI, Top and Bottom patterns, Harmonic patterns, and more. Midway through 2024, I delved deeper into blockchain technologies. When I discovered DexScreener with its incredible +10,000% gains, I was determined to compete with the veterans and snipe faster than anyone else. Three months later, I succeeded in consistently ranking among the top 10, and often the top 5, in snipes.</p> <p>This article will chronicle my amazing adventure and the lessons I learned along the way.</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#prerequisites","title":"Prerequisites","text":"<p>To follow along with this series, you should have some experience in Rust or at least a few years of programming experience in any language. The explanations will assume familiarity with basic programming concepts, as well as the ability to compile and use Rust programs.</p> <p>If you have suggestions for improvements, feel free to reach out to me at https://t.me/weestack.</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#disclaimer","title":"Disclaimer","text":"<p>The information provided in this series of articles is for educational purposes only and should not be considered financial or investment advice. Trading, including sniping tokens, carries significant risks, and there is no guarantee of profit.</p> <p>Any decisions you make based on the content shared here are solely your responsibility. I am not liable for any financial losses incurred as a result of implementing the strategies, code, or techniques discussed in these articles.</p> <p>Always trade responsibly. Never risk more money than you can afford to lose. It is essential to conduct your own research and consult with a professional financial advisor if necessary before engaging in any trading activities.</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#getting-our-hands-dirty","title":"Getting our hands dirty","text":"<p>Creating the base structure</p> <pre><code>mkdir Solana-Sniper\ncd Solana-Sniper\ntouch Cargo.toml\ncargo new sniper\n</code></pre> <p>For those familiar with Rust, we\u2019re not just creating a single binary. Instead, we\u2019ll be building multiple binaries along with a shared library that connects them. I chose this structure for its flexibility and ease of use. In my case, it allowed me to manage a command suite, sniper, algorithmic trader, and a shared library, all working seamlessly together. This modular approach makes it easier to maintain and expand the project in the future.</p> <p>Adding the root <code>Cargo.toml</code></p> <pre><code>[workspace]\nresolver = \"2\"\nmembers = [\n    \"sniper\"\n]\n\n[workspace.package]\nname = \"Solana-Sniper\"\nauthors = [\"Alexander H\u00f8gh\"]\nedition = \"2021\"\nhomepage = \"\"\nrepository = \"https://github.com/weestack/Solana-Sniper\"\nlicense = \"MIT\"\nkeywords = [\"solana\", \"sniper\", \"wsol\"]\nversion = \"0.1.0\"\nreadme = \"README.md\"\ncategories = [\"science\", \"algorithms\"]\npublish = false\n\n[workspace.lints.clippy]\nclone_on_ref_ptr = \"deny\"\nmissing_const_for_fn = \"deny\"\ntrivially_copy_pass_by_ref = \"deny\"\n\n[profile.release]\nlto = true\ncodegen-units = 1\n</code></pre> <p>In the <code>Cargo.toml</code>, we will define all the required dependencies. These dependencies will be inherited on a per-need basis in the different binaries, ensuring each component only includes the necessary libraries and modules for optimal performance and maintainability.</p> <p>You should now have a project that matches structure in the image below(Minus the .gitignore, LICENSE and README.md)</p> <p></p> <p>Our worktree after <code>cargo new sniper</code></p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#accepting-variables-from-a-env-file","title":"Accepting variables from a .env file","text":"<p>The first step is to create a secure and convenient way to store important variables for our sniper, such as paid RPC and WSS connections, private keys, snipe amounts, fee amounts, and other data. For security reasons, we should avoid adding this information to Git. This will be handled in the shared library mentioned earlier.</p> <p>Creating files for our library</p> <pre><code>cargo new --lib utils\nsed -i -e 's/name.workspace = true/name = \"utils\"/g' utils/Cargo.toml\nmkdir -p utils/src/env \ntouch utils/src/env/mod.rs\ntouch utils/src/env/env.rs\ntouch utils/src/env/errors.rs\n</code></pre> <p>Using the above steps, we create a new library package, rename it to \u201cutils,\u201d and add a folder named <code>env</code>. Inside the folder, we include <code>mod.rs</code>, <code>env.rs</code>, and <code>errors.rs</code> files.</p> <p>Before proceeding with any coding, add the following dependencies to the respective <code>Cargo.toml</code> files to ensure everything is set up.</p> <p>root <code>Cargo.toml</code></p> <p>Inside the root folders Cargo.toml, make these updates <pre><code>#Cargo.toml (root Cargo.toml)\n[...]\n[workspace.dependencies]\nutils = { path = \"utils\" }\ndotenv = \"0.15.0\"\nthiserror = \"2.0.9\"\nsolana-client = \"2.1.7\"\nsolana-program = \"2.1.7\"\nsolana-sdk = \"2.1.7\"\ntokio = \"1.42.0\"\n[...]\n\n\n#sniper/cargo.toml\n[...]\n[dependencies]\nutils = { workspace = true }\n[...]\n\n\n#utils/Cargo.toml\n[...]\n[dependencies]\ndotenv = { workspace = true }\nthiserror = { workspace = true }\nsolana-program = { workspace = true }\n[...]\n</code></pre></p> <p>Now that the dependencies are sorted, let\u2019s proceed with parsing the environment.</p> <p>utils/src/env/env.rs</p> <pre><code>use std::{env, fmt, fs, io};\nuse std::path::Path;\nuse std::sync::Arc;\nuse solana_program::native_token::lamports_to_sol;\nuse crate::env::errors::EnvErrors;\n\npub struct Env {\n    websocket_endpoint: Arc&lt;String&gt;,\n    rpc_endpoint: Arc&lt;String&gt;,\n    private_key: Arc&lt;String&gt;,\n\n    swap_amount: Arc&lt;u64&gt;,\n    swap_priority_fee: Arc&lt;u64&gt;,\n}\n\nimpl Env {\n    pub fn new() -&gt; Result&lt;Self, EnvErrors&gt; {\n        // Test if .env exists or give the option to create one from .env.dist\n        let path = Path::new(\".env\");\n        if ! path.exists() {\n            println!(\"Could not find .env, would you like to use .env.dist as a template instead? (y/n)\");\n            create_env().expect(\"Failed creating .env file\");\n        }\n        dotenv::from_path(\".env\").ok();\n\n        let websocket_endpoint = Arc::new(env::var(\"WEBSOCKET_ENDPOINT\")?);\n        let rpc_endpoint = Arc::new(env::var(\"RPC_ENDPOINT\")?);\n        let private_key = Arc::new(env::var(\"PRIVATE_KEYPAIR\")?);\n\n        let swap_amount = Arc::new(env::var(\"SWAP_AMOUNT\")?.parse::&lt;u64&gt;().unwrap());\n        let swap_priority_fee = Arc::new(env::var(\"SWAP_PRIORITY_FEE\")?.parse::&lt;u64&gt;().unwrap());\n\n        Ok(\n            Self {\n                websocket_endpoint,\n                rpc_endpoint,\n                private_key,\n                swap_amount,\n                swap_priority_fee,\n            }\n        )\n    }\n}\n\nimpl fmt::Display for Env {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        writeln!(f, \"===================== ENVS Loaded =====================\\r\\n\\\n        websocket_endpoint: {:?}\\r\\n\\\n        rpc endpoint:       {:?}\\r\\n\\\n        private wallet:     {:?}\\r\\n\\\n        swap amount:        {:?} sol\\r\\n\\\n        swap_priority_fee:  {:?} sol\\r\\n\\\n        total per trade:    {:?} sol\\r\\n\\\n        =====================================================\",\n                 self.websocket_endpoint,\n                 self.rpc_endpoint,\n                 self.private_key,\n                 lamports_to_sol(*self.swap_amount),\n                 lamports_to_sol(*self.swap_priority_fee),\n                 lamports_to_sol(*self.swap_amount.clone() + *self.swap_priority_fee.clone())\n        )\n    }\n}\n\nfn create_env() -&gt; std::io::Result&lt;()&gt; {\n    let source = \".env.dist\";\n    let destination = \".env\";\n\n    println!(\"Do you want to copy '{}' to '{}' (y/n)?\", source, destination);\n\n    let mut input = String::new();\n    io::stdin().read_line(&amp;mut input)?;\n\n    // Trim input and check the response\n    if input.trim().eq_ignore_ascii_case(\"y\") {\n        // Perform the copy\n        fs::copy(source, destination)?;\n        println!(\"File successfully copied to '{}'.\", destination);\n    } else {\n        println!(\"Operation canceled.\");\n    }\n\n    Ok(())\n}\n</code></pre> <p>In the above, we define the <code>Env</code> struct with a ::new method. As a bonus, if you haven't created a <code>.env</code> file with the correct variables, you can use the version from the GitHub repo, and it will prompt you to create the file. Additionally, we implement Display for <code>Env</code> to print it in a controlled way using println!.</p> <p>Note that we won't implement the correct data type for the private keypair until it's necessary.</p> <p>utils/src/env/errors.rs</p> <pre><code>use std::env::VarError;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum EnvErrors {\n    #[error(\"Missing .env file\")]\n    MissingEnvFile,\n\n    #[error(\"environment variable {0} set\")]\n    EnvVarNotFound(String, VarError),\n\n    #[error(\"Invalid ENV {0} file\")]\n    InvalidEnv(#[from] VarError),\n}\n</code></pre> <p>Here, we use <code>thiserror</code> to define the errors that may occur in <code>Env::new</code>, such as a missing file, missing environment variables, or invalid environment configurations.</p> <p>Now, let\u2019s give it a try.</p> <p>sniper/srv/mains.rs</p> <p><pre><code>use utils::env::env::Env;\nfn main() {\n    let env = Env::new();\n    println!(\"{}\", env.unwrap());\n\n}\n</code></pre> <pre><code>cargo run --bin sniper\n</code></pre></p> <p>this should print out something that corresponds to the image below</p> <p></p> <p>Output of the loaded env variables</p>","tags":["Solana"]},{"location":"blog/2025/01/06/writing-a-raydium-sniper-in-rust/#up-next","title":"Up next","text":"<p>In the next article, we\u2019ll dive into Solana transactions, websockets, and RPC to listen for newly created tokens. Thanks for reading this tutorial! Don\u2019t forget to subscribe so you won\u2019t miss the next part of the series.</p>","tags":["Solana"]},{"location":"cheat-sheets/compile-v8js/","title":"Compiling V8Js for Debian Bookworm","text":"<p>To compile V8Js for PHP 7.3 using a Docker build, follow these key steps:</p>","tags":["docker"]},{"location":"cheat-sheets/compile-v8js/#docker-build-overview","title":"Docker Build Overview","text":"<ol> <li>Install V8 Engine:    The Dockerfile installs Google\u2019s V8 JavaScript Engine version <code>9.9.115.9</code>:</li> <li>Installs essential build dependencies like <code>build-essential</code>, <code>libtinfo5</code>, <code>ninja-build</code>, etc.</li> <li>Clones the V8 source code and required depot tools from Google.</li> <li> <p>Builds the V8 engine and places the compiled shared libraries (<code>*.so</code>) and binaries in <code>/opt/v8/lib</code>, and headers in <code>/opt/v8/include</code>.</p> </li> <li> <p>Install PHP V8Js Extension:</p> </li> <li>The V8Js PHP extension is cloned from GitHub, compiled, and installed.</li> <li>It is configured to link with the V8 engine libraries located in <code>/opt/v8</code>.</li> <li>The PHP extension <code>v8js.so</code> is installed in <code>/usr/local/lib/php/extensions/no-debug-non-zts-20180731</code>.</li> <li>Finally, the extension is enabled with <code>docker-php-ext-enable v8js</code>.</li> </ol>","tags":["docker"]},{"location":"cheat-sheets/compile-v8js/#post-build-deployment","title":"Post-build Deployment","text":"<p>If you need to deploy the V8Js extension to a server outside the Docker container, you must:</p> <ol> <li> <p>Copy V8 Libraries:    Copy all the V8 shared libraries and resources from <code>/opt/v8</code> in the Docker container to the same location (<code>/opt/v8</code>) on the server.</p> </li> <li> <p>Copy PHP V8Js Extension:    Copy the <code>v8js.so</code> file from <code>/usr/local/lib/php/extensions/no-debug-non-zts-20180731</code> in the container to the same directory on the server.</p> </li> <li> <p>Ensure PHP Configuration:    Copy the PHP configuration file for V8Js (<code>/usr/local/etc/php/conf.d/docker-php-ext-v8js.ini</code>) from the Docker container to the same PHP configuration directory on the server.</p> </li> </ol>","tags":["docker"]},{"location":"cheat-sheets/compile-v8js/#key-files-to-transfer-from-docker-to-server","title":"Key Files to Transfer from Docker to Server","text":"<ul> <li>V8 Libraries: Copy <code>/opt/v8</code> (both libraries and headers) from the container to the server.</li> <li>PHP V8Js Extension: Copy <code>/usr/local/lib/php/extensions/no-debug-non-zts-20180731/v8js.so</code> from the container to the server.</li> <li>PHP Configuration: Copy <code>/usr/local/etc/php/conf.d/docker-php-ext-v8js.ini</code> to the server\u2019s PHP configuration directory.</li> </ul> <p>By ensuring these files are in place and paths are correctly set up on the server, your PHP 7.3 installation will be able to use the V8Js extension.</p> <pre><code>FROM php:7.3-fpm as BASE_PHP\nENV V8_VERSION=9.9.115.9\n\nRUN apt-get update -y --fix-missing &amp;&amp; apt-get upgrade -y;\n\n# Install v8js (see https://github.com/phpv8/v8js/blob/php7/README.Linux.md)\nRUN apt-get install -y --no-install-recommends \\\n    libtinfo5 libtinfo-dev \\\n    build-essential \\\n    curl \\\n    git \\\n    libglib2.0-dev \\\n    libxml2 \\\n    python \\\n    patchelf \\\n    ninja-build \\\n    &amp;&amp; cd /tmp \\\n    \\\n    &amp;&amp; git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git --progress --verbose \\\n    &amp;&amp; export PATH=\"$PATH:/tmp/depot_tools\" \\\n    \\\n    &amp;&amp; fetch v8 \\\n    &amp;&amp; cd v8 \\\n    &amp;&amp; git checkout $V8_VERSION \\\n    &amp;&amp; gclient sync \\\n    \\\n    &amp;&amp; tools/dev/v8gen.py -vv x64.release -- is_component_build=true use_custom_libcxx=false\n\nRUN export PATH=\"$PATH:/tmp/depot_tools\" \\\n    &amp;&amp; cd /tmp/v8 \\\n    &amp;&amp; ninja -C out.gn/x64.release/ \\\n    &amp;&amp; mkdir -p /opt/v8/lib &amp;&amp; mkdir -p /opt/v8/include \\\n    &amp;&amp; cp out.gn/x64.release/lib*.so out.gn/x64.release/*_blob.bin out.gn/x64.release/icudtl.dat /opt/v8/lib/ \\\n    &amp;&amp; cp -R include/* /opt/v8/include/ \\\n    &amp;&amp; apt-get install patchelf \\\n    &amp;&amp; for A in /opt/v8/lib/*.so; do patchelf --set-rpath '$ORIGIN' $A;done\n\n# Install php-v8js\nRUN cd /tmp \\\n    &amp;&amp; git clone https://github.com/phpv8/v8js.git \\\n    &amp;&amp; cd v8js \\\n    &amp;&amp; git checkout php7 \\\n    &amp;&amp; phpize \\\n    &amp;&amp; ./configure --with-v8js=/opt/v8 LDFLAGS=\"-lstdc++\" CPPFLAGS=\"-DV8_COMPRESS_POINTERS\" \\\n    &amp;&amp; make \\\n    &amp;&amp; make test \\\n    &amp;&amp; make install\n\nRUN ls -la /usr/local/etc/php/conf.d/ \\\n    &amp;&amp; ls -la /usr/local/lib/php/extensions/\n\nRUN docker-php-ext-enable v8js\nFROM php:7.3-fpm\n\nARG VCS_REF\nARG BUILD_DATE\nLABEL  org.label-schema.build-date=$BUILD_DATE \\\n        org.label-schema.name=\"PHP 7.3-FPM with V8JS\" \\\n        org.label-schema.vcs-ref=$VCS_REF \\\n        org.label-schema.vcs-url=\"https://github.com/nkahoang/docker-v8js-php\"\n\nCOPY --from=BASE_PHP /opt /opt\nCOPY --from=BASE_PHP /usr/local/etc/php/conf.d/docker-php-ext-v8js.ini /usr/local/etc/php/conf.d/\nCOPY --from=BASE_PHP /usr/local/lib/php/extensions/no-debug-non-zts-20180731 /usr/local/lib/php/extensions/no-debug-non-zts-20180731\nRUN apt-get update &amp;&amp; apt-get install -y \\\n      libfreetype6-dev \\\n      libjpeg62-turbo-dev \\\n      libpng-dev\nRUN docker-php-ext-configure gd --with-freetype-dir=/usr --with-jpeg-dir=/usr --with-png-dir=/usr \\\n    &amp;&amp; docker-php-ext-install -j$(nproc) gd\n</code></pre>","tags":["docker"]},{"location":"cheat-sheets/curl/","title":"Curl","text":"<p>Curl can be used for a variety of tasks and is my go-to tool for testing web protocols, verifying mail credentials\u2014heck, even testing FTP!</p> <p>This cheat sheet contains some of the most common ways I use Curl.</p>","tags":["curl"]},{"location":"cheat-sheets/curl/#acknowledgments","title":"Acknowledgments","text":"<p>First of all, thank you to Everything Curl for the great content and explanations\u2014far better than what I\u2019ll include in my cheat sheet!</p>","tags":["curl"]},{"location":"cheat-sheets/curl/#checking-redirects","title":"Checking redirects","text":"<p>Unlike your browser, Curl does not cache requests.  This makes it a great tool for testing 301 or 302  redirects in real time\u2014allowing you to verify changes on the fly.</p> <pre><code>curl -I https://example.com\n</code></pre>","tags":["curl"]},{"location":"cheat-sheets/curl/#sending-mails","title":"Sending mails","text":"<p>As a senior DevOps engineer, I often receive messages like,  \"The SMTP login you provided isn't working [...]\". Over the years,  I\u2019ve found that testing with Curl is incredibly easy,  so I\u2019ve made it a habit to send an email to the developer as a proof of concept.  I then share the exact command I used and help them debug their code to identify the issue.</p> <p>Create a mail file <code>mail.txt</code> <pre><code>From: Alexander Ho\u00f8gh &lt;Alexander@helius.dk&gt;\nTo: who ever &lt;their@mail.com&gt;\nSubject: Proof of concept\nDate: Fri, 1 Jan 2025 08:00:00\n\nDear developer, so sorry to hear about your issue,\nlets look it over together and debug what went wrong ^_^\n\nBest regards Alexander,\nHave a fantastic day\n</code></pre></p> <p><code>Command line:</code> <pre><code>smtp://Username:Password@provider:port --mail-from alexander@provider.IDN --mail-rcpt their@mail.com --upload-file mail.txt\n# Note that if your username or password contains @ or other characters then a uri ended string is supported on the protocol level\n# Lets say the username is alexander@helius.dk and password is password123\nsmtp://alexander%40helius.dk:password123@myprovider:587 --mail-from alexander@helius.dk --mail-rcpt their@mail.com --upload-file mail.txt\n</code></pre></p>","tags":["curl"]},{"location":"cheat-sheets/grub_recovery/","title":"Grub recovery","text":"<p>If, for some reason, your Linux system won't boot, you can spin up a rescue system. This issue might occur after a kernel upgrade or downgrade.</p> <p>First of all, if the system uses RAID, you need to assemble it: <pre><code>mdadm --assemble --scan\n</code></pre> Next, mount the appropriate disks: <pre><code># lsblk to identify them\nmount /dev/md127 /mnt/\nmount /dev/md126 /mnt/boot/\n# Last md device will be swap, skip that\nmount --bind /dev /mnt/dev\nmount --bind /proc /mnt/proc\nmount --bind /sys /mnt/sys\n</code></pre> Now, for the GRUB commands to work, change the root environment and make it think <code>/mnt</code> is the root. This can be achieved with <code>chroot</code>: <pre><code>chroot /mnt\ngrub-install\n# If grub install fails use: on all devices\ngrub-install /dev/nvme0n1 &amp;&amp; grub-install /dev/nvme1n1\n</code></pre> Finally, update GRUB: <pre><code>grub-update\n</code></pre> Depending on your system and the specific issue, you might need to take additional steps to get the system working. This guide serves as a baseline for troubleshooting when systems won't boot.</p> <p>If the system is still not able to boot, then try to investigate the boot partition</p> <p>a few note worthy things that could be an issue: 1) fstab no longer has the correct disk for boot 2) grub is not installed on the disk install with   <pre><code>grub-install /dev/disk0n1\n</code></pre></p>","tags":["linux","grub2"]},{"location":"cheat-sheets/mdadm/","title":"mdadm replace disk","text":"<p>When working with dedicated hardware, there are times when a disk may fail or become unstable. This is where RAID comes into play, allowing data to be duplicated across disks using different strategies to maintain redundancy and minimize downtime.</p> <p>Use the following commands to list all disks and identify the RAID setup: <pre><code># Use lsblk to list all disks\n# Check raid details if in doubt\nmdadm --detail /dev/md0\nmdadm --detail /dev/md1\nmdadm --detail /dev/md2\n</code></pre></p> <p>Take note of the faulty disks and use diagnostic tools such as smartctl to confirm the disk's health.</p> <p>Mark the faulty disk as such in the RAID array: <pre><code>mdadm --manage --set-faulty /dev/md0 /dev/nvme1n1p1\nmdadm --manage --set-faulty /dev/md1 /dev/nvme1n1p2\nmdadm --manage --set-faulty /dev/md2 /dev/nvme1n1p3\n</code></pre></p> <p>Finally, remove the faulty disk from the RAID: <pre><code>mdadm /dev/md0 --remove /dev/nvme1n1p1\nmdadm /dev/md1 --remove /dev/nvme1n1p2\nmdadm /dev/md2 --remove /dev/nvme1n1p3\n</code></pre></p> <p>Now that the faulty disk has been removed, the RAID is in a degraded state. Proceed with formatting the replacement disk.</p> <p>Write zeroes to the new disk to ensure it's ready for use: <pre><code>dd if=/dev/zero of=/dev/nvme0n1 bs=1M status=progress\n</code></pre></p> <p>Clone the partition table from a functioning disk to the new disk: <pre><code>sfdisk -d /dev/nvme0n1 | sfdisk /dev/nvme1n1\n</code></pre></p> <p>Add the new disk to the RAID and allow the synchronization to complete. Depending on the size and speed of the RAID, this process may take several hours: <pre><code>mdadm /dev/md0 -a /dev/nvme1n1p1\nmdadm /dev/md1 -a /dev/nvme1n1p2\nmdadm /dev/md2 -a /dev/nvme1n1p3\n</code></pre></p> <p>Use the following command to monitor the status of the RAID synchronization in real-time: <pre><code>watch -n 1 'cat /proc/mdstat'\n</code></pre></p>","tags":["linux","mdadm"]},{"location":"cheat-sheets/nginx-argbased-redirect/","title":"Nginx Dynamic Redirect Based on Query Args","text":"<p>Recently, I faced the following scenario at work: - A client was preparing to launch their new site - 40,000+ indexed pages ea/domain, 6 domains in total - There were third-party developers involved in the project    </p> <p>For backup purposes, someone ended up creating a rewrite engine like <code>/seo/product/&lt;product_number&gt;/</code> and wanted dynamic rewrites to it based on query args, specifically <code>/old-product/?id=12341-12</code>, which then needed to redirect to the engine, which would then rewrite further... see the problem?</p> <p>When changing URLs, it's important to tell Google through redirects. However, if we do a rewrite:  </p> <p><code>/old-product/?id=12341-12</code> \u2192 <code>/seo/product/&lt;product_number&gt;/</code> \u2192 <code>/new-product/cool-url-12341/</code> </p> <p>Then we have a problem because the odds are that Google will think the middle point is the new URL for that page, e.g., <code>/seo/product/&lt;product_number&gt;/</code>, and not the correct address: <code>/new-product/cool-url-12341/</code>.  </p> <p>Instead of the rewrites, I created a hidden rewrite layer such that, as far as the user or Google is aware, you are taken from <code>/old-product/?id=12341-12</code> \u2192 <code>/new-product/cool-url-12341/</code>. This is how I achieved it.</p>","tags":["nginx"]},{"location":"cheat-sheets/nginx-argbased-redirect/#nginx-maps","title":"Nginx Maps","text":"<p>Put in nginx.conf: <pre><code>map $arg_id $seo_redirect_arg {\n  default \"\";\n\n  ~^([0-9]+)- 0;\n}\n\nmap $request_uri $seo_redirect_uri {\n  default 0;\n\n  ~^/se/cs-seo/product-redirect/ 1;\n  ~^/en/cs-seo/product-redirect/ 1;\n  ~^/cs-seo/product-redirect/    1;\n}\n\nmap $seo_redirect_uri:$seo_redirect_arg $seo_redirect_map {\n  default 1;\n\n  ~^0:([0-9]+) 0;\n}\n</code></pre> We use maps as a starter because they are faster than if statements.  </p>","tags":["nginx"]},{"location":"cheat-sheets/nginx-argbased-redirect/#named-location","title":"Named Location","text":"<p>Then we put a named location wherever within the server block or an included file: <pre><code># custom error code to handle redirect from where ever needed\nerror_page 379 = @internal_redirect;\n\nlocation @internal_redirect {\n    internal;\n    set $product_id \"\";\n    set $dir \"/\";\n\n    if ($arg_id ~ \"^([0-9]+)-\") {\n        set $product_id $1;\n    }\n\n    if ($product_id = \"\") {\n      return 404;\n    }\n\n    if ($request_uri ~ \"^/se/\") {\n      set $dir \"/se/\";\n    }\n\n    if ($request_uri ~ \"^/en/\") {\n      set $dir \"/en/\";\n    }\n\n    proxy_pass_request_body off;\n    proxy_set_header Content-Length \"\";\n    proxy_intercept_errors on;\n    proxy_pass http://127.0.0.1:8080${dir}cs-seo/product-redirect/$product_id;\n    proxy_set_header Host $host;\n}\n</code></pre> In case you are wondering, the variables defined in the maps are not referenceable within a named location.</p> <p>We create an error page for the return of HTTP 379 (can be whatever\u2014just stay clear of the usual ones). Doing it this way, we are able to call the named location within an if statement, which is normally a hassle. For example, if you want <code>try_files</code> within an if, that's not possible.</p>","tags":["nginx"]},{"location":"cheat-sheets/nginx-argbased-redirect/#final-integration","title":"Final Integration","text":"<p>Finally, the part that glues it all together: <pre><code>location / {\n   [...]\n   if ($seo_redirect_map = 0) {\n     # Redirects to internal_redirect\n     return 379;\n   }\n\n   index &lt;index_files&gt;.php;\n   try_files $uri $uri/ /index.php$is_args$args;\n}\n</code></pre></p>","tags":["nginx"]},{"location":"cheat-sheets/ollama/","title":"Ollama","text":"<p>Ollama is a lightweight, open-source framework for running and managing large language models (LLMs) locally.</p> <p>These are my cheat sheets to use it for everyday tasks!</p>","tags":["ollama"]},{"location":"cheat-sheets/ollama/#commit-messages","title":"Commit messages","text":"<p>Note that I use Mac and Zsh and this build is for Mac and Zsh.</p> <p>In my case I have an extra bin folder at the user level eg ~/bin, you probably have to adjust it to run from somewhere else <pre><code>#!/usr/bin/env zsh\n\nDIFF=$(git diff --cached $1)\n\nSUMMARY=$(\n  ollama run llama3.2 &lt;&lt;EOF\nGenerate a raw text commit message for the following diff.\nKeep commit message concise and to the point.\nMake the first line the title (100 characters max) and the rest the body:\nDo not show raw output of Diff in the message\nDo not add meta data such as characters\n$DIFF\nEOF\n)\n\nSTRIPPED_SUMMARY=$( echo $SUMMARY | sed -e 's|&lt;think&gt;.*&lt;/think&gt;||g' )\n\necho -n $STRIPPED_SUMMARY\n\necho -n \" [Use result for commit, rerun or abort y/r/n] \"\nread DECISION\n\nif [[ $DECISION == [rR] ]]; then\n  exec ~/bin/oc.sh\nfi\n\nif [[ $DECISION == [yY] ]]; then\n  git commit -m \"$STRIPPED_SUMMARY\"\nfi\n\nif [[ $DECISION == [nN] ]]; then\n  echo \"Bye not commiting anything\"\nfi\n</code></pre></p>","tags":["ollama"]},{"location":"blog/category/rust/","title":"Rust","text":""},{"location":"blog/category/hot-reloading/","title":"Hot reloading","text":""},{"location":"blog/category/solana-sniper/","title":"Solana Sniper","text":""},{"location":"blog/category/solana-smart-contract/","title":"Solana Smart contract","text":""},{"location":"blog/category/solana-stable-coin/","title":"Solana stable coin","text":""}]}